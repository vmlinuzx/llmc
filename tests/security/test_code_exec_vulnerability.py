from llmc_mcp.tools.code_exec import execute_code


def dummy_tool_caller(name, args):
    return {"data": f"Called {name} with {args}", "meta": {}}


def test_exec_vulnerability():
    # This PoC bypasses the simple import check and lists the root directory.
    # It demonstrates that the blacklist is not sufficient to prevent
    # malicious code execution.

    # In a real attack, this could be used to read sensitive files,
    # establish a reverse shell, or perform other malicious actions.

    malicious_code = "print(__import__('os').listdir('/'))"

    # We need to bypass the isolation check for this test.
    # In a real attack, this could be achieved by exploiting the
    # "Hybrid Mode" or by finding a flaw in the isolation implementation.

    # For this test, we will temporarily disable the isolation check
    # by monkeypatching the require_isolation function.
    from llmc_mcp import isolation

    original_require_isolation = isolation.require_isolation
    isolation.require_isolation = lambda x: None

    result = execute_code(malicious_code, dummy_tool_caller)

    # Restore the original function
    isolation.require_isolation = original_require_isolation

    assert result.success
    assert result.error is None

    # The output should contain a list of files and directories in the root
    # of the filesystem. We'll check for some common ones.
    assert "etc" in result.stdout
    assert "bin" in result.stdout
    assert "home" in result.stdout
