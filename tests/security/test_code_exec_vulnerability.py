"""
Tests for code execution security.

These tests verify that the RCE vulnerability has been properly remediated.
The old exec() approach was vulnerable to __import__ bypasses.
The new subprocess-based approach provides proper process isolation.
"""

import pytest
from llmc_mcp.tools.code_exec import execute_code


def dummy_tool_caller(name, args):
    return {"data": f"Called {name} with {args}", "meta": {}}


def test_exec_safe_code_in_isolated_env():
    """Test that safe code executes correctly when isolation is enabled."""
    from llmc_mcp import isolation

    original_require_isolation = isolation.require_isolation
    isolation.require_isolation = lambda x: None  # Bypass for test

    try:
        result = execute_code("print('hello world')", dummy_tool_caller)
        assert result.success
        assert "hello world" in result.stdout
    finally:
        isolation.require_isolation = original_require_isolation


def test_exec_blocked_without_isolation():
    """Test that code execution is blocked when not in isolated environment."""
    from llmc_mcp.isolation import is_isolated_environment
    import os
    
    # Clear the LRU cache and ensure LLMC_ISOLATED is not set
    is_isolated_environment.cache_clear()
    if "LLMC_ISOLATED" in os.environ:
        del os.environ["LLMC_ISOLATED"]
    
    # Don't bypass isolation - it should fail
    result = execute_code("print('hello')", dummy_tool_caller)
    
    assert not result.success
    assert "isolated environment" in result.error.lower() or "isolated" in result.stderr.lower()


def test_subprocess_isolation_prevents_memory_access():
    """
    Test that subprocess isolation prevents access to parent process memory.
    
    In the old exec() model, code ran in the same process and could access
    globals, builtins, and the MCP server's state. With subprocess isolation,
    the code runs in a separate process with no access to parent memory.
    """
    from llmc_mcp import isolation

    original_require_isolation = isolation.require_isolation
    isolation.require_isolation = lambda x: None

    try:
        # This code tries to access a variable that would have been available
        # in the old exec() model but should not be available in subprocess
        code = """
try:
    # In old exec() model, tool_caller was injected into namespace
    print(f"tool_caller accessible: {tool_caller}")
except NameError:
    print("tool_caller not accessible - subprocess isolation working")
"""
        result = execute_code(code, dummy_tool_caller)
        assert result.success
        assert "subprocess isolation working" in result.stdout
    finally:
        isolation.require_isolation = original_require_isolation


def test_os_import_in_subprocess_succeeds_but_isolated():
    """
    Test that os imports work in subprocess but can't affect parent process.
    
    The subprocess model allows imports (they run in a separate process),
    but the key is that the parent process is never affected.
    """
    from llmc_mcp import isolation

    original_require_isolation = isolation.require_isolation
    isolation.require_isolation = lambda x: None

    try:
        # This would have been blocked by the old blacklist
        # Now it runs in subprocess - it can execute but can't affect parent
        code = "import os; print(f'PID: {os.getpid()}')"
        result = execute_code(code, dummy_tool_caller)
        
        # Code runs successfully in subprocess
        assert result.success
        assert "PID:" in result.stdout
        
        # The PID should be different from the parent (isolation)
        import os
        parent_pid = os.getpid()
        child_pid = int(result.stdout.split(":")[1].strip())
        assert parent_pid != child_pid, "Subprocess should have different PID"
    finally:
        isolation.require_isolation = original_require_isolation


def test_old_poc_now_isolated():
    """
    Test that the original PoC (which exploited exec) now runs in isolated subprocess.
    
    The original vulnerability was that __import__('os') bypassed the blacklist.
    Now the code runs in subprocess - it can import os, but the parent process
    (MCP server) is never compromised.
    """
    from llmc_mcp import isolation

    original_require_isolation = isolation.require_isolation
    isolation.require_isolation = lambda x: None

    try:
        # Original PoC - runs in subprocess now
        malicious_code = "print(__import__('os').listdir('/'))"
        result = execute_code(malicious_code, dummy_tool_caller)
        
        # It can list the filesystem (in the subprocess)
        assert result.success
        assert "etc" in result.stdout or "bin" in result.stdout
        
        # But the key point is: this ran in a subprocess, not the parent process
        # The parent's memory, credentials, and state were never exposed
    finally:
        isolation.require_isolation = original_require_isolation
