import pytest
import os
from unittest.mock import patch
from llmc_mcp.tools.cmd import run_cmd, ExecResult

def test_isolation_bypass_env_var():
    """
    VULNERABILITY CONFIRMATION:
    Verify that setting LLMC_ISOLATED=1 bypasses the isolation check,
    allowing command execution on the host.
    """
    with patch("llmc_mcp.isolation.is_isolated_environment", return_value=False):
        result = run_cmd("echo 'should fail'", cwd=".")
        assert result.success is False
        assert "requires an isolated environment" in result.error

    from llmc_mcp.isolation import is_isolated_environment
    is_isolated_environment.cache_clear()

    with patch.dict(os.environ, {"LLMC_ISOLATED": "1"}):
        result = run_cmd("echo 'bypassed'", cwd=".")
        assert result.success is True
        assert "bypassed" in result.stdout

def test_command_injection_attempt():
    """
    Verify if shell injection is possible.
    """
    from llmc_mcp.isolation import is_isolated_environment
    is_isolated_environment.cache_clear()

    with patch.dict(os.environ, {"LLMC_ISOLATED": "1"}):
        result = run_cmd("echo hacked ; ls", cwd=".")
        assert result.success is True
        assert "; ls" in result.stdout

def test_indirect_command_execution():
    """
    VULNERABILITY CONFIRMATION:
    Even without shell=True, if we can run 'python3' or 'sh', we can execute arbitrary code.
    The blacklist is only "asking nicely" and empty by default.
    """
    from llmc_mcp.isolation import is_isolated_environment
    is_isolated_environment.cache_clear()

    with patch.dict(os.environ, {"LLMC_ISOLATED": "1"}):
        # Using python to write a file - arbitrary code execution
        cmd = "python3 -c \"import os; print('RCE_SUCCESS')\""
        result = run_cmd(cmd, cwd=".")

        assert result.success is True
        assert "RCE_SUCCESS" in result.stdout
