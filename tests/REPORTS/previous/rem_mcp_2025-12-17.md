
# Rem's MCP Tool Test Report - 2025-12-17

This report details the security and functionality testing of the LLMC MCP server tools.

## Executive Summary

A **critical security vulnerability** was discovered in the `run_cmd` tool. The isolation check, which is designed to prevent the tool from running on an un-sandboxed host, is flawed and can be easily bypassed. This allows for arbitrary code execution on the host machine where the MCP server is running.

## Tool: `llmc_mcp.tools.cmd`

### Test Plan

A series of tests were designed to validate the functionality and security of the `run_cmd` function. The tests covered:

- Basic command execution (success and failure)
- Command timeouts
- Command blacklisting
- Handling of empty and invalid commands
- Correctness of the working directory (`cwd`)
- **Crucially**, the isolation check that should prevent the tool from running on a non-isolated host.

### Findings

- **CRITICAL VULNERABILITY:** The `require_isolation` check is ineffective.
    - **Description:** The `is_isolated_environment` function incorrectly identifies the host environment as isolated, even when it is not. This is likely due to an overly broad check of `/proc/1/cgroup`. In the test environment, this check returns `True`, allowing `run_cmd` to execute commands without any sandboxing.
    - **Impact:** Arbitrary code execution on the host system. An attacker could use this to read/write files, install malware, or take over the machine.
    - **Test Evidence:** The `test_isolation_fail` test case, which was designed to ensure that `run_cmd` would fail without the `LLMC_ISOLATED=1` environment variable, failed. The test confirmed that `is_isolated_environment()` returns `True` even when no other isolation indicators are present.
    - **Recommendation:** The `is_isolated_environment` function needs to be rewritten to be more specific and reliable. It should not be possible to bypass this check simply by running in a standard Linux environment that happens to have a cgroup structure that looks like a container.

- **Other findings:**
    - The `timeout`, `blacklist`, `cwd`, and other features of `run_cmd` work as expected *when the isolation check is manually bypassed*.

### Next Steps

- The `is_isolated_environment` function must be fixed immediately.
- A full audit of all tools that rely on `require_isolation` is necessary.

---
This report will be updated as testing of other tools continues.

---

## Tool: `llmc_mcp.tools.code_exec`

### Test Plan

Tests were designed to assess the security of the `execute_code` function, focusing on:
- The `require_isolation` check.
- The blocklist for `import` statements.
- The overall risk of executing arbitrary code with `exec()`.
- The functionality of `generate_stubs`.

### Findings

- **CRITICAL VULNERABILITY:** `execute_code` is vulnerable to Remote Code Execution (RCE) via two separate vectors.

    1.  **Ineffective Isolation Check:**
        - **Description:** This tool suffers from the same flawed `require_isolation` check as `run_cmd`. The `is_isolated_environment()` function incorrectly returns `True`, allowing `execute_code` to run on what it believes is a safe, sandboxed environment.
        - **Impact:** Arbitrary code execution on the host system.
        - **Test Evidence:** The `test_isolation_fail_vulnerability` test case passed, showing that `execute_code` ran without the `LLMC_ISOLATED=1` flag.

    2.  **Weak Import Block Bypass:**
        - **Description:** The mechanism to prevent dangerous imports like `os` and `subprocess` is a simple string check (`"import os" in code`). This is trivial to bypass using Python's `__import__` built-in function.
        - **Impact:** Arbitrary code execution. An attacker can import any library and execute any command.
        - **Test Evidence:** The `test_import_block_bypass_vulnerability` test successfully executed `__import__('os').system('echo ...')`. The command was executed by the host system, proving the vulnerability. The output appeared in the main process's stdout, not the captured stdout of the tool, further demonstrating the lack of containment.

- **Bug in `generate_stubs`:** The `generate_stubs` function was found to have a bug related to how it processes tool definitions, but this is minor compared to the security flaws.

### Conclusion

The `execute_code` tool is critically insecure. It provides a direct, un-sandboxed RCE vector. The combination of a faulty isolation check and a weak import blocklist makes it trivial to exploit.

### Recommendation

- **Immediate Disablement:** This tool should be disabled in production immediately.
- **Complete Rewrite:** If code execution is a required feature, it must be done in a properly sandboxed environment (e.g., a separate, ephemeral Docker container for each execution, or a technology like `nsjail` with a heavily restricted filesystem and network access). The current approach of using `exec()` in the main server process is fundamentally unsafe.

---

## Tool: `llmc_mcp.tools.exec`

### Findings

- **CRITICAL VULNERABILITY:** This tool is a backward-compatibility shim for `llmc_mcp.tools.cmd`. It directly imports and exposes all functions from `cmd.py`.
- **Conclusion:** It is vulnerable to the same RCE as `cmd.py` because it relies on the same flawed `require_isolation` check. All findings for `cmd.py` apply to this tool.

---

## Tools: `llmc_mcp.tools.fs` and `llmc_mcp.tools.fs_protected`

### Analysis

These two files provide a comprehensive set of tools for filesystem access.
- `fs.py` contains the core functions for reading, writing, and managing files and directories.
- `fs_protected.py` wraps the write operations from `fs.py` with a MAASL "stomp guard", which is a concurrency locking mechanism to prevent race conditions between different agents.

### Security Model

The security of both toolsets rests entirely on the `validate_path` function in `fs.py`. This function enforces a path-based security model using an `allowed_roots` configuration parameter. All file access must be to a path that resolves to be within one of the directories listed in `allowed_roots`.

The toolset includes defenses against:
- Path traversal (`../`)
- Accessing absolute paths outside the `allowed_roots`.
- Symlink escapes (symlinks pointing outside `allowed_roots`).
- Null byte injection in paths.
- Access to device files (e.g., `/dev/null`).

Crucially, **these tools do not use the flawed `require_isolation` check**. Their security depends entirely on the server operator configuring `allowed_roots` correctly. If `allowed_roots` is misconfigured (e.g., set to `/`), these tools would grant broad, dangerous access to the host filesystem.

### Test Plan & Findings

A test suite (`tests/rem_mcp_test_fs.py`) was created to test the `allowed_roots` enforcement.

- **Results:** All tests passed. The `validate_path` function correctly prevented all attempts to access files or directories outside the configured `safe_root`.
- **Conclusion:** The path validation security model appears to be implemented correctly. No vulnerabilities were found in the implementation of the `fs` tools themselves. The security of the system depends on the correct operational configuration of the `allowed_roots`.

The MAASL locking in `fs_protected.py` is a concurrency feature, not a security sandbox, and was not tested for race conditions as the primary focus is on security vulnerabilities. All path validation logic is inherited from `fs.py` and is covered by the existing tests.

---

## Tools: `llmc_mcp.tools.rag` and `llmc_mcp.tools.rag_protected`

### Analysis

These files provide tools to interact with the Retrieval-Augmented Generation (RAG) system.
- `rag.py` contains functions for searching the RAG index (`rag_search`, `rag_search_enriched`).
- `rag_protected.py` provides functions for writing to the RAG database (`enrich_spans_protected`), using the same MAASL locking mechanism as `fs_protected.py` to prevent concurrent writes.

### Security Model & Findings

The security of these tools is a concern due to several design choices:

1.  **Unvalidated `repo_root`:** The core functions take a `repo_root` path as a parameter. Unlike the `fs` tools, this path is not validated against a set of `allowed_roots`. An agent could potentially specify any path on the filesystem. While the tool would likely fail if a valid RAG index isn't found at that path, this lack of validation is a significant security gap. An attacker could potentially point to a malicious or very large directory, causing performance issues or other unexpected behavior.

2.  **Use of `os.chdir()`:** The `rag_search` and `rag_search_enriched` functions change the current working directory of the entire server process to the provided `repo_root`. This is a dangerous and highly discouraged practice in a server environment, as it can lead to unpredictable behavior, especially with multiple concurrent agents. It could cause relative paths used elsewhere in the application to break or lead to race conditions.

### Conclusion

While no direct RCE was found, the RAG tools contain significant security smells and poor design patterns. The lack of path validation for `repo_root` combined with the use of `os.chdir()` creates a potential for denial-of-service, information disclosure, or other attacks, depending on the implementation of the underlying RAG indexing and searching logic.

### Recommendation

- **Remove `os.chdir()`:** The RAG implementation should be refactored to not depend on the process's current working directory. The `repo_root` should be passed explicitly to all underlying functions.
- **Implement Path Validation:** The `repo_root` parameter should be validated against a list of allowed RAG directories, similar to the `allowed_roots` model in the `fs` tools.

---

## Tool: `llmc_mcp.tools.te`

### Analysis

This file provides a tool `te_run` that acts as a wrapper for a command-line executable, expected to be named `te`. It uses `subprocess.run` to execute this command. The tool does not call `require_isolation`.

### Security Model & Findings

The security of this tool is weak and presents a clear path to Remote Code Execution if the server's environment variables can be influenced.

- **CRITICAL VULNERABILITY (RCE via Environment Variable):**
    - **Description:** The `te_run` function determines which executable to run by checking the `LLMC_TE_EXE` environment variable, falling back to `te`. If an attacker can control the environment variables of the MCP server process, they can set `LLMC_TE_EXE` to any executable on the system (e.g., `/bin/bash`, `python`) and use the `args` parameter of the `te_run` tool to pass arbitrary commands to it.
    - **Impact:** Full Remote Code Execution on the host system, with the privileges of the MCP server process.
    - **Test Evidence:** The `test_rce_via_env_var_vulnerability` test case in `tests/rem_mcp_test_te.py` successfully demonstrated this. By setting `LLMC_TE_EXE` to `/bin/echo`, the test was able to execute `echo` with arbitrary arguments, proving that the executable can be substituted.

- **Unvalidated `cwd` Parameter:** The tool accepts a `cwd` (current working directory) parameter that is passed directly to `subprocess.run` without being validated against any allowed directories. This allows an attacker to run the `te` command in any directory on the filesystem.

### Conclusion

The `te_run` tool is a significant security risk. It provides a straightforward RCE vector for any attacker who can manipulate the server's environment. The design assumes that the environment is trusted and that the `te` executable itself is secure, which are dangerous assumptions for a tool-using agent.

### Recommendation

- **Do not trust environment variables for executables:** The path to the `te` executable should be a static, hard-coded path or a configuration value that is not sourced from an environment variable at runtime.
- **Implement `require_isolation`:** If this tool is intended to be powerful, it should be subject to the same isolation checks as `run_cmd` and `execute_code`.
- **Validate `cwd`:** The `cwd` parameter should be validated against a set of allowed roots, similar to the `fs` tools.

### Addendum: `llmc_mcp.tools.te_repo`

The file `te_repo.py` contains thin wrappers (`repo_read`, `rag_query`) that directly call the vulnerable `te_run` tool. They inherit the same RCE vulnerability and should be considered equally insecure.

---

## Tools: `llmc_mcp.tools.linux_ops`

This directory contains tools for direct Linux host inspection and manipulation.

### Tool: `sysinfo.py`

- **Analysis:** This tool provides a read-only snapshot of system resources (CPU, RAM, disk). It safely uses the `psutil` library or, as a fallback, reads from `/proc` and runs hardcoded, safe `df` commands.
- **Conclusion:** This tool is **safe**.

### Tool: `proc.py`

- **Analysis:** This file provides tools for listing, killing, and starting processes on the host. The `mcp_linux_proc_start` function allows an agent to start any process with any command (e.g., `bash`). The `mcp_linux_proc_kill` function allows an agent to kill almost any process on the host. These tools do not have any sandboxing or isolation checks.
- **Findings: MAXIMUM SEVERITY VULNERABILITY**
    - **Description:** The `mcp_linux_proc_start` tool provides direct, unsandboxed Remote Code Execution. It is a thin wrapper around starting a new process. The agent has full control over the command to be executed. The accompanying `send` and `read` tools give the agent an interactive shell on the host.
    - **Impact:** Complete and total compromise of the host machine. An attacker can use this to read/write any file, install persistent malware, exfiltrate data, and pivot to other systems on the network.
    - **Test Evidence:** The `test_proc_start_rce_vulnerability` test in `tests/rem_mcp_test_linux_ops.py` confirmed that an arbitrary command (`touch /tmp/rem_proc_exploit.txt`) could be executed successfully.

### Conclusion on `linux_ops`

The `linux_ops` toolset contains the most severe and direct vulnerabilities in the entire MCP tool suite. The `proc.py` file single-handedly provides a complete, interactive RCE channel. The existence of this tool demonstrates a fundamental misunderstanding of agent security, assuming the agent is fully trusted.

### Recommendation

- **IMMEDIATE REMOVAL:** The entire `linux_ops/proc.py` file and all tools within it must be removed from the MCP server immediately. There is no safe way to expose this level of functionality to an untrusted or semi-trusted agent.
- **Configuration by Default:** All `linux_ops` features are gated by a feature flag in a `LinuxOpsConfig` object. This configuration should be set to `disabled` by default in all production environments.




