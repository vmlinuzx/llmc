F...FF.................................................................. [  3%]
..................................F...F.FF.ss........................... [  6%]
.............................ssss......................................s [  9%]
ss.s..FFF......................FF.FF.FFFsssss............FF.F...FFFsssss [ 12%]
ss.........sFssssssssssssssssssssssss.sssssss...........Fss............. [ 15%]
ss...................................................................... [ 18%]
.........................................................Fs............. [ 21%]
..............F.s.................................FFF..................F [ 24%]
F...s.ss..........F.........Fs............F......s.........F.........ss. [ 28%]
....................s............sssss.................................. [ 31%]
.........s.............................................................. [ 34%]
...............................F........................................ [ 37%]
.................F.F......................F............................. [ 40%]
........................................................................ [ 43%]
..............................................................ssssssssss [ 46%]
ss...................................................................... [ 49%]
........................................................................ [ 53%]
.................................................ssss.....FF............ [ 56%]
........................................................................ [ 59%]
....................................................................FFFF [ 62%]
EEEs..................FFs.....F......ssssssssss......................... [ 65%]
......................sssss.....s.........FFF.F......F......FF.........F [ 68%]
........................................................................ [ 71%]
........................................................................ [ 74%]
....................ssssss.........FF................................... [ 77%]
........................................................................ [ 81%]
..........FFFFFFFFFFFFFFFFFF..FFFFFF...F.F.F.....F...................... [ 84%]
.......................sssssssssssssssssss.............................. [ 87%]
..................................................................ss.... [ 90%]
........................................................................ [ 93%]
...........................FF.............sF............................ [ 96%]
............................................s................ssssssssss. [ 99%]
....                                                                     [100%]
==================================== ERRORS ====================================
______ ERROR at setup of TestMCPHttpServerRoutes.test_health_route_exists ______

self = <test_mcp_http_transport.TestMCPHttpServerRoutes object at 0x74ccb7739610>

    @pytest.fixture
    def http_server(self):
        """Create HTTP server instance."""
        from llmc_mcp.transport.http_server import MCPHttpServer
    
        mock_server = Mock()
        mock_server.tools = [Mock(name="test_tool")]  # 1 fake tool
        mock_server.server = Mock()
    
        mock_config = Mock()
        mock_config.server.host = "127.0.0.1"
        mock_config.server.port = 8765
    
>       return MCPHttpServer(mock_server, mock_config)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/home/vmlinux/src/llmc/tests/test_mcp_http_transport.py:102: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/vmlinux/src/llmc/llmc_mcp/transport/http_server.py:70: in __init__
    self.app = self._create_app()
               ^^^^^^^^^^^^^^^^^^
/home/vmlinux/src/llmc/llmc_mcp/transport/http_server.py:82: in _create_app
    app = Starlette(
/home/vmlinux/.local/lib/python3.12/site-packages/starlette/applications.py:69: in __init__
    self.router = Router(routes, on_startup=on_startup, on_shutdown=on_shutdown, lifespan=lifespan)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.routing.Router object at 0x74cca45cb0b0>
routes = [Route(path='/health', name='_health', methods=['GET', 'HEAD']), Route(path='/sse', name='_handle_sse', methods=['GET'...<bound method SseServerTransport.handle_post_message of <mcp.server.sse.SseServerTransport object at 0x74cca45cb770>>)]
redirect_slashes = True, default = None
on_startup = [<bound method MCPHttpServer._on_startup of <llmc_mcp.transport.http_server.MCPHttpServer object at 0x74cca45c9850>>]
on_shutdown = [<bound method MCPHttpServer._on_shutdown of <llmc_mcp.transport.http_server.MCPHttpServer object at 0x74cca45c9850>>]
lifespan = None

    def __init__(
        self,
        routes: Sequence[BaseRoute] | None = None,
        redirect_slashes: bool = True,
        default: ASGIApp | None = None,
        on_startup: Sequence[Callable[[], Any]] | None = None,
        on_shutdown: Sequence[Callable[[], Any]] | None = None,
        # the generic to Lifespan[AppType] is the type of the top level application
        # which the router cannot know statically, so we use Any
        lifespan: Lifespan[Any] | None = None,
        *,
        middleware: Sequence[Middleware] | None = None,
    ) -> None:
        self.routes = [] if routes is None else list(routes)
        self.redirect_slashes = redirect_slashes
        self.default = self.not_found if default is None else default
        self.on_startup = [] if on_startup is None else list(on_startup)
        self.on_shutdown = [] if on_shutdown is None else list(on_shutdown)
    
        if on_startup or on_shutdown:
>           warnings.warn(
                "The on_startup and on_shutdown parameters are deprecated, and they "
                "will be removed on version 1.0. Use the lifespan parameter instead. "
                "See more about it on https://starlette.dev/lifespan/.",
                DeprecationWarning,
            )
E           DeprecationWarning: The on_startup and on_shutdown parameters are deprecated, and they will be removed on version 1.0. Use the lifespan parameter instead. See more about it on https://starlette.dev/lifespan/.

/home/vmlinux/.local/lib/python3.12/site-packages/starlette/routing.py:601: DeprecationWarning
_______ ERROR at setup of TestMCPHttpServerRoutes.test_sse_route_exists ________

self = <test_mcp_http_transport.TestMCPHttpServerRoutes object at 0x74ccb77388f0>

    @pytest.fixture
    def http_server(self):
        """Create HTTP server instance."""
        from llmc_mcp.transport.http_server import MCPHttpServer
    
        mock_server = Mock()
        mock_server.tools = [Mock(name="test_tool")]  # 1 fake tool
        mock_server.server = Mock()
    
        mock_config = Mock()
        mock_config.server.host = "127.0.0.1"
        mock_config.server.port = 8765
    
>       return MCPHttpServer(mock_server, mock_config)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/home/vmlinux/src/llmc/tests/test_mcp_http_transport.py:102: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/vmlinux/src/llmc/llmc_mcp/transport/http_server.py:70: in __init__
    self.app = self._create_app()
               ^^^^^^^^^^^^^^^^^^
/home/vmlinux/src/llmc/llmc_mcp/transport/http_server.py:82: in _create_app
    app = Starlette(
/home/vmlinux/.local/lib/python3.12/site-packages/starlette/applications.py:69: in __init__
    self.router = Router(routes, on_startup=on_startup, on_shutdown=on_shutdown, lifespan=lifespan)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.routing.Router object at 0x74cca45ca420>
routes = [Route(path='/health', name='_health', methods=['GET', 'HEAD']), Route(path='/sse', name='_handle_sse', methods=['GET'...<bound method SseServerTransport.handle_post_message of <mcp.server.sse.SseServerTransport object at 0x74cca45ca030>>)]
redirect_slashes = True, default = None
on_startup = [<bound method MCPHttpServer._on_startup of <llmc_mcp.transport.http_server.MCPHttpServer object at 0x74cca45ca000>>]
on_shutdown = [<bound method MCPHttpServer._on_shutdown of <llmc_mcp.transport.http_server.MCPHttpServer object at 0x74cca45ca000>>]
lifespan = None

    def __init__(
        self,
        routes: Sequence[BaseRoute] | None = None,
        redirect_slashes: bool = True,
        default: ASGIApp | None = None,
        on_startup: Sequence[Callable[[], Any]] | None = None,
        on_shutdown: Sequence[Callable[[], Any]] | None = None,
        # the generic to Lifespan[AppType] is the type of the top level application
        # which the router cannot know statically, so we use Any
        lifespan: Lifespan[Any] | None = None,
        *,
        middleware: Sequence[Middleware] | None = None,
    ) -> None:
        self.routes = [] if routes is None else list(routes)
        self.redirect_slashes = redirect_slashes
        self.default = self.not_found if default is None else default
        self.on_startup = [] if on_startup is None else list(on_startup)
        self.on_shutdown = [] if on_shutdown is None else list(on_shutdown)
    
        if on_startup or on_shutdown:
>           warnings.warn(
                "The on_startup and on_shutdown parameters are deprecated, and they "
                "will be removed on version 1.0. Use the lifespan parameter instead. "
                "See more about it on https://starlette.dev/lifespan/.",
                DeprecationWarning,
            )
E           DeprecationWarning: The on_startup and on_shutdown parameters are deprecated, and they will be removed on version 1.0. Use the lifespan parameter instead. See more about it on https://starlette.dev/lifespan/.

/home/vmlinux/.local/lib/python3.12/site-packages/starlette/routing.py:601: DeprecationWarning
_____ ERROR at setup of TestMCPHttpServerRoutes.test_messages_route_exists _____

self = <test_mcp_http_transport.TestMCPHttpServerRoutes object at 0x74ccb7738380>

    @pytest.fixture
    def http_server(self):
        """Create HTTP server instance."""
        from llmc_mcp.transport.http_server import MCPHttpServer
    
        mock_server = Mock()
        mock_server.tools = [Mock(name="test_tool")]  # 1 fake tool
        mock_server.server = Mock()
    
        mock_config = Mock()
        mock_config.server.host = "127.0.0.1"
        mock_config.server.port = 8765
    
>       return MCPHttpServer(mock_server, mock_config)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/home/vmlinux/src/llmc/tests/test_mcp_http_transport.py:102: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/vmlinux/src/llmc/llmc_mcp/transport/http_server.py:70: in __init__
    self.app = self._create_app()
               ^^^^^^^^^^^^^^^^^^
/home/vmlinux/src/llmc/llmc_mcp/transport/http_server.py:82: in _create_app
    app = Starlette(
/home/vmlinux/.local/lib/python3.12/site-packages/starlette/applications.py:69: in __init__
    self.router = Router(routes, on_startup=on_startup, on_shutdown=on_shutdown, lifespan=lifespan)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.routing.Router object at 0x74cca45c97f0>
routes = [Route(path='/health', name='_health', methods=['GET', 'HEAD']), Route(path='/sse', name='_handle_sse', methods=['GET'...<bound method SseServerTransport.handle_post_message of <mcp.server.sse.SseServerTransport object at 0x74cca45cae10>>)]
redirect_slashes = True, default = None
on_startup = [<bound method MCPHttpServer._on_startup of <llmc_mcp.transport.http_server.MCPHttpServer object at 0x74cca45cb470>>]
on_shutdown = [<bound method MCPHttpServer._on_shutdown of <llmc_mcp.transport.http_server.MCPHttpServer object at 0x74cca45cb470>>]
lifespan = None

    def __init__(
        self,
        routes: Sequence[BaseRoute] | None = None,
        redirect_slashes: bool = True,
        default: ASGIApp | None = None,
        on_startup: Sequence[Callable[[], Any]] | None = None,
        on_shutdown: Sequence[Callable[[], Any]] | None = None,
        # the generic to Lifespan[AppType] is the type of the top level application
        # which the router cannot know statically, so we use Any
        lifespan: Lifespan[Any] | None = None,
        *,
        middleware: Sequence[Middleware] | None = None,
    ) -> None:
        self.routes = [] if routes is None else list(routes)
        self.redirect_slashes = redirect_slashes
        self.default = self.not_found if default is None else default
        self.on_startup = [] if on_startup is None else list(on_startup)
        self.on_shutdown = [] if on_shutdown is None else list(on_shutdown)
    
        if on_startup or on_shutdown:
>           warnings.warn(
                "The on_startup and on_shutdown parameters are deprecated, and they "
                "will be removed on version 1.0. Use the lifespan parameter instead. "
                "See more about it on https://starlette.dev/lifespan/.",
                DeprecationWarning,
            )
E           DeprecationWarning: The on_startup and on_shutdown parameters are deprecated, and they will be removed on version 1.0. Use the lifespan parameter instead. See more about it on https://starlette.dev/lifespan/.

/home/vmlinux/.local/lib/python3.12/site-packages/starlette/routing.py:601: DeprecationWarning
=================================== FAILURES ===================================
___________________________________ test_mcp ___________________________________

mode = <typer.models.OptionInfo object at 0x74cd0d7a9250>
tools = <typer.models.OptionInfo object at 0x74cd0d7a93d0>
output = <typer.models.OptionInfo object at 0x74cd0d7a9490>
fail_fast = <typer.models.OptionInfo object at 0x74cd0d7a9730>

    @app.command()
    def test_mcp(
        mode: str = typer.Option("quick", help="Test mode: quick, standard, ruthless"),
        tools: List[str] = typer.Option(None, "--tools", "-t", help="Specific tools to test"),
        output: Path = typer.Option(None, "--output", "-o", help="Output report path"),
        fail_fast: bool = typer.Option(False, "--fail-fast", "-x", help="Stop on first failure"),
    ):
        """Run MCP tool tests.
    
        Modes:
            quick    - Smoke tests only (~30s)
            standard - Core functionality (~2min)
            ruthless - Edge cases, security, performance (~10min)
        """
        if mode not in ["quick", "standard", "ruthless"]:
            print(f"Error: Invalid mode '{mode}'. Please choose from 'quick', 'standard', or 'ruthless'.")
>           raise typer.Exit(1)
E           click.exceptions.Exit: 1

llmc/commands/test_mcp.py:25: Exit
----------------------------- Captured stdout call -----------------------------
Error: Invalid mode '<typer.models.OptionInfo object at 0x74cd0d7a9250>'. Please choose from 'quick', 'standard', or 'ruthless'.
__________________________ test_detect_context_family __________________________

    def test_detect_context_family():
        """Test context detection for 'mother had cancer' - should be family"""
        text = "mother had cancer"
        entity = "cancer"
    
        start = text.find(entity)
        end = start + len(entity)
        entity_span = (start, end)
    
        detector = ContextDetector()
        result = detector.detect_context(text, entity_span)
    
        assert result["family"] == True, "Expected 'cancer' to be family history"
        assert result["negated"] == False, "Should not be negated"
>       assert (
            result["historical"] == False
        ), "Should not be historical (it's family, not patient's history)"
E       AssertionError: Should not be historical (it's family, not patient's history)
E       assert True == False

llmc/rag/extractors/test_context_detector.py:85: AssertionError
___________________ test_detect_context_multiple_categories ____________________

    def test_detect_context_multiple_categories():
        """Test when entity matches multiple context categories"""
        text = "No family history of diabetes"
        entity = "diabetes"
    
        start = text.find(entity)
        end = start + len(entity)
        entity_span = (start, end)
    
        detector = ContextDetector()
        result = detector.detect_context(text, entity_span)
    
        # 'No' indicates negation, 'family history' indicates family
        assert result["negated"] == True, "Expected 'diabetes' to be negated due to 'No'"
        assert (
            result["family"] == True
        ), "Expected 'diabetes' to be family due to 'family history'"
>       assert (
            result["historical"] == False
        ), "Should not be historical (it's family history)"
E       AssertionError: Should not be historical (it's family history)
E       assert True == False

llmc/rag/extractors/test_context_detector.py:108: AssertionError
________________________ TestScorer.test_load_defaults _________________________

self = <rag.tests.test_scoring.TestScorer object at 0x74cd0a995220>
mock_load_config = <MagicMock name='load_config' id='128422606791568'>

    @patch("llmc.rag.scoring.load_config")
    def test_load_defaults(self, mock_load_config):
        mock_load_config.return_value = {}
        scorer = Scorer()
    
>       assert scorer.config["code_boost"] == 0.08
E       assert 0.15 == 0.08

llmc/rag/tests/test_scoring.py:13: AssertionError
___________________ TestScorer.test_score_extension_neutral ____________________

self = <rag.tests.test_scoring.TestScorer object at 0x74cd0a997140>

    def test_score_extension_neutral(self):
        scorer = Scorer()
    
        # Code boost
>       assert scorer.score_extension("main.py", "neutral") == 0.08
E       AssertionError: assert 0.15 == 0.08
E        +  where 0.15 = score_extension('main.py', 'neutral')
E        +    where score_extension = <llmc.rag.scoring.Scorer object at 0x74ccb6c02e10>.score_extension

llmc/rag/tests/test_scoring.py:55: AssertionError
_____________________ TestScorer.test_score_filename_match _____________________

self = <rag.tests.test_scoring.TestScorer object at 0x74cd0a997740>

    def test_score_filename_match(self):
        scorer = Scorer()
    
>       assert scorer.score_filename_match("config", "config.py") == 0.15 # Stem match
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError: assert 0.3 == 0.15
E        +  where 0.3 = score_filename_match('config', 'config.py')
E        +    where score_filename_match = <llmc.rag.scoring.Scorer object at 0x74ccb6d47b00>.score_filename_match

llmc/rag/tests/test_scoring.py:79: AssertionError
________________ test_search_eval_harness_runs_and_prefers_rag _________________

tmp_path = PosixPath('/tmp/pytest-of-vmlinux/pytest-57/test_search_eval_harness_runs_0')

    @pytest.mark.slow
    def test_search_eval_harness_runs_and_prefers_rag(tmp_path: Path):
        repo = Path(".").resolve()
>       result = run(repo, QUERIES, OUTDIR, k=5, mode="both")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

llmc/rag/tests/test_search_eval_canary.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
llmc/rag/eval/search_eval.py:122: in run
    rows = load_queries(queries_path)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
llmc/rag/eval/search_eval.py:27: in load_queries
    with path.open("r", encoding="utf-8") as handle:
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('DOCS/RAG_NAV/P9_Search/canary_queries.jsonl'), mode = 'r'
buffering = -1, encoding = 'utf-8', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return io.open(self, mode, buffering, encoding, errors, newline)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       FileNotFoundError: [Errno 2] No such file or directory: 'DOCS/RAG_NAV/P9_Search/canary_queries.jsonl'

/usr/lib/python3.12/pathlib.py:1015: FileNotFoundError
_____ TestAgentContextOverflow.test_unbounded_tool_output_context_overflow _____

self = <test_agent_context_overflow.TestAgentContextOverflow object at 0x74ccb821e3f0>
MockToolRegistry = <MagicMock name='ToolRegistry' id='128422587333808'>
MockOllamaBackend = <MagicMock name='OllamaBackend' id='128422586205200'>
agent_config = AgentConfig(provider='ollama', model='qwen3-next-80b-nothink', context_budget=4000, response_reserve=1024, timeout=300)

    @patch("llmc_agent.agent.OllamaBackend")
    @patch("llmc_agent.tools.ToolRegistry")
    @pytest.mark.asyncio  # Mark the test as async
    async def test_unbounded_tool_output_context_overflow(
        self,
        MockToolRegistry,  # This is the mocked class
        MockOllamaBackend,  # This is the mocked class
        agent_config,
    ):
        """
        Tests that a large tool output causes context overflow by not being truncated
        before being sent back to the LLM.
        """
        # Create instances of the mocked classes
        mock_ollama_backend_instance = MockOllamaBackend.return_value
        mock_tool_registry_instance = MockToolRegistry.return_value
    
        def _verbose_tool_func():
            return VERY_LARGE_STRING
    
        # Create a Tool instance
        mock_verbose_tool = Tool(
            name="verbose_tool",
            description="Returns a very large string.",
            tier=ToolTier.WALK,  # Or any appropriate tier
            function=_verbose_tool_func,
            parameters={"type": "object", "properties": {}, "required": []},
        )
    
        # Configure the mocked tool registry instance
        mock_tool_registry_instance.get_tool.side_effect = lambda name: (
            mock_verbose_tool if name == "verbose_tool" else None
        )
        mock_tool_registry_instance.get_tools_for_tier.return_value = [
            mock_verbose_tool
        ]
        mock_tool_registry_instance.unlock_tier = (
            MagicMock()
        )  # Mock the unlock_tier method
    
        # Configure the mocked OllamaBackend instance's generate_with_tools method
        mock_ollama_backend_instance.generate_with_tools = AsyncMock(
            side_effect=[
                # First call to generate_with_tools: LLM requests to use verbose_tool
                GenerateResponse(
                    content="",
                    tokens_prompt=100,
                    tokens_completion=50,
                    model="mock_model",
                    finish_reason="tool_calls",
                    tool_calls=[
                        {"function": {"name": "verbose_tool", "arguments": {}}}
                    ],
                ),
                # Second call to generate_with_tools: LLM processes tool output
                GenerateResponse(
                    content="Some final response after processing the verbose tool output.",
                    tokens_prompt=200,
                    tokens_completion=100,
                    model="mock_model",
                    finish_reason="stop",
                    tool_calls=[],
                ),
            ]
        )
    
        # Initialize the agent (it will use the patched classes)
        agent = Agent(config=agent_config)
    
        # 2. Call agent.ask_with_tools, which should trigger the tool call
        await agent.ask_with_tools(
            "Please use the verbose tool to give me some information."
        )
    
        # 3. Assertions
        # The generate_with_tools method should have been called twice
>       assert mock_ollama_backend_instance.generate_with_tools.call_count == 2
E       AssertionError: assert 1 == 2
E        +  where 1 = <AsyncMock name='OllamaBackend().generate_with_tools' id='128422587827120'>.call_count
E        +    where <AsyncMock name='OllamaBackend().generate_with_tools' id='128422587827120'> = <MagicMock name='OllamaBackend()' id='128422588188288'>.generate_with_tools

/home/vmlinux/src/llmc/tests/gap/test_agent_context_overflow.py:117: AssertionError
_________________ test_agent_handles_malformed_json_tool_args __________________

    @pytest.mark.allow_network
    def test_agent_handles_malformed_json_tool_args():
        """
        Test that the agent handles invalid JSON in tool arguments gracefully.
        It should catch the JSONDecodeError and report it back to the model
        as a tool error message.
        """
        import asyncio
    
>       asyncio.run(_test_impl())

/home/vmlinux/src/llmc/tests/gap/test_agent_robustness.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/asyncio/runners.py:194: in run
    return runner.run(main)
           ^^^^^^^^^^^^^^^^
/usr/lib/python3.12/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/asyncio/base_events.py:687: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def _test_impl():
        # 1. Setup
        # Create a mock config
        config = MagicMock(spec=Config)
        config.ollama = MagicMock()
        config.ollama.url = "http://mock"
        config.ollama.timeout = 10
        config.ollama.temperature = 0.0
        config.ollama.num_ctx = 100
    
        # Disable RAG to simplify
        config.rag = MagicMock()
        config.rag.enabled = False
    
        config.agent = MagicMock()
        config.agent.model = "mock-model"
        config.agent.context_budget = 1000
        config.agent.response_reserve = 100
    
        # Initialize agent
        agent = Agent(config)
    
        # Mock the backend
        mock_backend = AsyncMock()
        agent.ollama = mock_backend
    
        # 2. Execution
        # Define the malformed tool call
        # "read_file" is a valid tool in the registry (Tier 1)
        # "{ unquoted_key: 5 }" is invalid JSON (keys must be quoted)
        malformed_tool_call = {
            "function": {"name": "read_file", "arguments": "{ unquoted_key: 5 }"},
            "id": "call_123",
        }
    
        # Response 1: Triggers the error
        response_1 = GenerateResponse(
            content="I will read the file.",
            tokens_prompt=10,
            tokens_completion=10,
            model="mock",
            finish_reason="tool_calls",
            tool_calls=[malformed_tool_call],
        )
    
        # Response 2: Completes the interaction
        response_2 = GenerateResponse(
            content="Sorry, I made a mistake with the JSON.",
            tokens_prompt=10,
            tokens_completion=10,
            model="mock",
            finish_reason="stop",
            tool_calls=[],
        )
    
        mock_backend.generate_with_tools.side_effect = [response_1, response_2]
    
        # Call ask_with_tools
        # "read" is a keyword to unlock WALK tier (where read_file is available)
        await agent.ask_with_tools("read this file", max_tool_rounds=2)
    
        # 3. Verification
        # Verify that generate_with_tools was called twice
>       assert mock_backend.generate_with_tools.call_count == 2
E       AssertionError: assert 1 == 2
E        +  where 1 = <AsyncMock name='mock.generate_with_tools' id='128422586714736'>.call_count
E        +    where <AsyncMock name='mock.generate_with_tools' id='128422586714736'> = <AsyncMock id='128422586743648'>.generate_with_tools

/home/vmlinux/src/llmc/tests/gap/test_agent_robustness.py:86: AssertionError
___________ TestAgentToolFeedback.test_silent_tool_failure_feedback ____________

self = <test_agent_tool_feedback.TestAgentToolFeedback testMethod=test_silent_tool_failure_feedback>

    async def test_silent_tool_failure_feedback(self):
        """
        Test that the agent provides feedback when a tool is not available in the current tier.
        SDD: tests/gap/SDDs/SDD-Agent-SilentToolFailure.md
        """
        # Setup Config
        mock_config = MagicMock()
        mock_config.ollama.url = "http://localhost:11434"
        mock_config.ollama.timeout = 30
        mock_config.ollama.temperature = 0.0
        mock_config.ollama.num_ctx = 4096
        mock_config.rag.enabled = False
        mock_config.agent.model = "test-model"
        mock_config.agent.context_budget = 8192
        mock_config.agent.response_reserve = 1024
        mock_config.rag.include_summary = True
        mock_config.rag.max_results = 5
        mock_config.rag.min_score = 0.5
    
        # Mock OllamaBackend
        with patch("llmc_agent.agent.OllamaBackend") as MockOllamaBackend:
            mock_backend_instance = AsyncMock()
            MockOllamaBackend.return_value = mock_backend_instance
    
            # Instantiate Agent
            agent = Agent(mock_config)
    
            # Force ToolRegistry to WALK tier
            agent.tools.current_tier = ToolTier.WALK
    
            # Mock responses
            # Response 1: Tool call to 'write_file' (RUN tier)
            tool_call_args = '{"path": "test.txt", "content": "hello"}'
            response_1 = GenerateResponse(
                content="",
                tokens_prompt=10,
                tokens_completion=10,
                model="test-model",
                finish_reason="tool_calls",
                tool_calls=[
                    {
                        "function": {"name": "write_file", "arguments": tool_call_args},
                        "id": "call_123",
                    }
                ],
            )
    
            # Response 2: Text response (simulating model reacting to feedback)
            response_2 = GenerateResponse(
                content="I see I cannot write files.",
                tokens_prompt=20,
                tokens_completion=10,
                model="test-model",
                finish_reason="stop",
                tool_calls=[],
            )
    
            # We might need more responses if it loops multiple times due to failure
            mock_backend_instance.generate_with_tools.side_effect = [
                response_1,
                response_2,
                response_2,
                response_2,
            ]
    
            # Patch detect_intent_tier to prevent auto-upgrade to RUN
            with patch(
                "llmc_agent.tools.detect_intent_tier", return_value=ToolTier.WALK
            ):
                await agent.ask_with_tools("Please write this file")
    
            # Assertions
    
            # Check the inputs to the second call
            # We expect at least 2 calls. If the agent silently failed and looped, it might have called more times
            # with the exact same input (missing tool feedback).
>           assert mock_backend_instance.generate_with_tools.call_count >= 2
E           AssertionError: assert 1 >= 2
E            +  where 1 = <AsyncMock name='OllamaBackend().generate_with_tools' id='128422588193712'>.call_count
E            +    where <AsyncMock name='OllamaBackend().generate_with_tools' id='128422588193712'> = <AsyncMock name='OllamaBackend()' id='128422587740000'>.generate_with_tools

/home/vmlinux/src/llmc/tests/gap/test_agent_tool_feedback.py:89: AssertionError
______________________________ test_dos_via_exit _______________________________

    def test_dos_via_exit():
        """
        Test that calling execute_code with sys.exit() propagates SystemExit
        when isolation is bypassed (mocked).
        """
        # Patch require_isolation to bypass the environment check
        with patch("llmc_mcp.isolation.require_isolation") as mock_iso:
            # Code that triggers sys.exit(1)
            code = "import sys; sys.exit(1)"
    
            # We expect SystemExit to be raised because the current implementation
            # catches Exception but not BaseException (which SystemExit inherits from).
>           with pytest.raises(SystemExit):
E           Failed: DID NOT RAISE <class 'SystemExit'>

/home/vmlinux/src/llmc/tests/gap/test_mcp_dos.py:20: Failed
_______________________ test_dos_via_keyboard_interrupt ________________________

    def test_dos_via_keyboard_interrupt():
        """
        Test that calling execute_code with raise KeyboardInterrupt propagates KeyboardInterrupt.
        """
        # Patch require_isolation to bypass the environment check
        with patch("llmc_mcp.isolation.require_isolation") as mock_iso:
            # Code that raises KeyboardInterrupt
            code = "raise KeyboardInterrupt"
    
            # We expect KeyboardInterrupt to be raised.
>           with pytest.raises(KeyboardInterrupt):
E           Failed: DID NOT RAISE <class 'KeyboardInterrupt'>

/home/vmlinux/src/llmc/tests/gap/test_mcp_dos.py:34: Failed
______________________ test_write_file_append_blocks_fifo ______________________

tmp_fifo = PosixPath('/tmp/pytest-of-vmlinux/pytest-57/test_write_file_append_blocks_0/test.fifo')

    def test_write_file_append_blocks_fifo(tmp_fifo):
        """Verify write_file (append) blocks on FIFO (Gap Confirmation)."""
        # This test is EXPECTED to fail (hang) if the gap exists.
        # So we want to assert that it DOES NOT hang.
    
        allowed_roots = [str(tmp_fifo.parent)]
        content = "test"
        mode = "append"
    
        result_container = {}
    
        def target():
            try:
                result_container["result"] = write_file(
                    str(tmp_fifo), allowed_roots, content, mode=mode
                )
            except Exception as e:
                result_container["error"] = str(e)
    
        t = threading.Thread(target=target)
        t.start()
        t.join(timeout=2.0)
    
        if t.is_alive():
            # Ideally we kill the thread but in Python we can't easily.
            # We just report failure.
>           pytest.fail(
                "write_file hung on FIFO write! GAP CONFIRMED: write_file(append) allows opening FIFO."
            )
E           Failed: write_file hung on FIFO write! GAP CONFIRMED: write_file(append) allows opening FIFO.

/home/vmlinux/src/llmc/tests/gap/test_mcp_fs_devices.py:70: Failed
___________________ test_router_resilience_heuristic_failure ___________________

    def test_router_resilience_heuristic_failure():
        """
        Test that classify_query catches exceptions from heuristic modules
        and falls back to a default route.
        """
        with patch(
            "llmc.routing.code_heuristics.score_all",
            side_effect=ValueError("Simulated failure"),
        ):
            # This should not raise an exception
>           result = classify_query("how to install")
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/home/vmlinux/src/llmc/tests/gap/test_router_resilience.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/vmlinux/src/llmc/llmc/routing/query_type.py:51: in classify_query
    code_sig = ch.score_all(text, cfg.get("code_detection"))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1134: in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1138: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='score_all' id='128422585772720'>
args = ('how to install', {}), kwargs = {}
effect = ValueError('Simulated failure')

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
>               raise effect
E               ValueError: Simulated failure

/usr/lib/python3.12/unittest/mock.py:1193: ValueError
__________________________ test_chat_shell_injection ___________________________

    def test_chat_shell_injection():
        """Verify that shell injection characters are sanitized."""
        malicious_prompt = "; ls -la"
    
        with patch("llmc_agent.cli.main") as mock_agent_main:
            # Capture sys.argv at the time agent_main is called
            captured_argv = []
            def side_effect(*args, **kwargs):
                captured_argv.extend(sys.argv)
            mock_agent_main.side_effect = side_effect
    
            result = runner.invoke(app, ["chat", malicious_prompt])
    
            assert result.exit_code == 0
            mock_agent_main.assert_called_once()
    
            # Verify sanitization
            # sys.argv[0] is "llmc-chat", sys.argv[1] is the prompt
            assert len(captured_argv) >= 2
            prompt_passed = captured_argv[1]
    
            # Assert that the prompt passed is NOT the exact malicious string
            # This confirms some form of sanitization or escaping occurred
>           assert prompt_passed != malicious_prompt, "Shell injection prompt was not sanitized"
E           AssertionError: Shell injection prompt was not sanitized
E           assert '; ls -la' != '; ls -la'

/home/vmlinux/src/llmc/tests/main/test_main.py:39: AssertionError
___________________________ test_chat_xss_injection ____________________________

    def test_chat_xss_injection():
        """Verify that XSS payloads are sanitized."""
        malicious_prompt = "<script>alert('XSS')</script>"
    
        with patch("llmc_agent.cli.main") as mock_agent_main:
            captured_argv = []
            def side_effect(*args, **kwargs):
                captured_argv.extend(sys.argv)
            mock_agent_main.side_effect = side_effect
    
            result = runner.invoke(app, ["chat", malicious_prompt])
    
            assert result.exit_code == 0
            mock_agent_main.assert_called_once()
    
            assert len(captured_argv) >= 2
            prompt_passed = captured_argv[1]
    
>           assert prompt_passed != malicious_prompt, "XSS prompt was not sanitized"
E           AssertionError: XSS prompt was not sanitized
E           assert "<script>alert('XSS')</script>" != "<script>alert('XSS')</script>"

/home/vmlinux/src/llmc/tests/main/test_main.py:59: AssertionError
___________________________ test_chat_sql_injection ____________________________

    def test_chat_sql_injection():
        """Verify that SQL injection payloads are sanitized."""
        malicious_prompt = "' OR 1=1 --"
    
        with patch("llmc_agent.cli.main") as mock_agent_main:
            captured_argv = []
            def side_effect(*args, **kwargs):
                captured_argv.extend(sys.argv)
            mock_agent_main.side_effect = side_effect
    
            result = runner.invoke(app, ["chat", malicious_prompt])
    
            assert result.exit_code == 0
            mock_agent_main.assert_called_once()
    
            assert len(captured_argv) >= 2
            prompt_passed = captured_argv[1]
    
>           assert prompt_passed != malicious_prompt, "SQL injection prompt was not sanitized"
E           AssertionError: SQL injection prompt was not sanitized
E           assert "' OR 1=1 --" != "' OR 1=1 --"

/home/vmlinux/src/llmc/tests/main/test_main.py:79: AssertionError
___________________ TestExecuteCode.test_call_tool_injection ___________________

self = <test_code_exec.TestExecuteCode object at 0x74ccb804c950>

        def test_call_tool_injection(self):
            """Verify _call_tool is available in executed code namespace."""
            mock_caller = make_mock_tool_caller(
                {"test_tool": {"data": "mock_result", "meta": {}}}
            )
    
            result = execute_code(
                code="""
    result = _call_tool("test_tool", {"arg": "value"})
    print(f"Got: {result}")
    """,
                tool_caller=mock_caller,
            )
>           assert result.success
E           assert False
E            +  where False = CodeExecResult(success=False, stdout='', stderr='Traceback (most recent call last):\n  File "/tmp/tmprmqzrkpl.py", lin...   ^^^^^^^^^^\nNameError: name \'_call_tool\' is not defined\n', return_value=None, error='Process exited with code 1').success

/home/vmlinux/src/llmc/tests/mcp/test_code_exec.py:57: AssertionError
_____________ TestExecuteCode.test_import_stub_calls_injected_tool _____________

self = <test_code_exec.TestExecuteCode object at 0x74ccb804cd40>
tmp_path = PosixPath('/tmp/pytest-of-vmlinux/pytest-57/test_import_stub_calls_injecte0')

        def test_import_stub_calls_injected_tool(self, tmp_path):
            """
            Critical test: Verify that imported stubs use builtins._call_tool.
    
            This was the bug - stubs imported _call_tool from the module which
            raised NotImplementedError, instead of using the injected version.
            """
            # Generate a test stub
            test_tool = Tool(
                name="my_test_tool",
                description="A test tool",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "query": {"type": "string", "description": "Test query"}
                    },
                    "required": ["query"],
                },
            )
    
            stubs_dir = tmp_path / "stubs"
            generate_stubs([test_tool], Path("stubs"), tmp_path)
    
            # Mock caller that records what was called
            calls = []
    
            def tracking_caller(name: str, args: dict) -> dict:
                calls.append((name, args))
                return {"data": "success", "meta": {}}
    
            # Execute code that imports and uses the stub
            result = execute_code(
                code="""
    from stubs import my_test_tool
    result = my_test_tool(query="test query")
    print(f"Result: {result}")
    """,
                tool_caller=tracking_caller,
                stubs_dir=stubs_dir,
            )
    
>           assert (
                result.success
            ), f"Execution failed: {result.error}\nstderr: {result.stderr}"
E           AssertionError: Execution failed: Process exited with code 1
E             stderr: Traceback (most recent call last):
E               File "/tmp/tmpw4yx4c9o.py", line 3, in <module>
E                 result = my_test_tool(query="test query")
E                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               File "/tmp/pytest-of-vmlinux/pytest-57/test_import_stub_calls_injecte0/stubs/my_test_tool.py", line 24, in my_test_tool
E                 return _call_tool("my_test_tool", locals())
E                        ^^^^^^^^^^
E             NameError: name '_call_tool' is not defined
E             
E           assert False
E            +  where False = CodeExecResult(success=False, stdout='', stderr='Traceback (most recent call last):\n  File "/tmp/tmpw4yx4c9o.py", lin...   ^^^^^^^^^^\nNameError: name \'_call_tool\' is not defined\n', return_value=None, error='Process exited with code 1').success

/home/vmlinux/src/llmc/tests/mcp/test_code_exec.py:101: AssertionError
_____________________ TestExecuteCode.test_timeout_capture _____________________

self = <test_code_exec.TestExecuteCode object at 0x74ccb804d580>

    @pytest.mark.allow_sleep
    def test_timeout_capture(self):
        """Test that stderr is captured on error."""
        result = execute_code(
            code='raise ValueError("test error")',
            tool_caller=lambda n, a: {},
        )
    
        assert not result.success
>       assert "ValueError" in result.error
E       assert 'ValueError' in 'Process exited with code 1'
E        +  where 'Process exited with code 1' = CodeExecResult(success=False, stdout='', stderr='Traceback (most recent call last):\n  File "/tmp/tmp199qnz_q.py", lin...\n    raise ValueError("test error")\nValueError: test error\n', return_value=None, error='Process exited with code 1').error

/home/vmlinux/src/llmc/tests/mcp/test_code_exec.py:137: AssertionError
__________________ test_run_untrusted_python_security_warning __________________

    def test_run_untrusted_python_security_warning():
        """Verify that the tool's docstring includes a prominent security warning."""
>       assert "WARNING" in code_exec.run_untrusted_python.__doc__
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: module 'llmc_mcp.tools.code_exec' has no attribute 'run_untrusted_python'

/home/vmlinux/src/llmc/tests/mcp/test_code_exec_security.py:7: AttributeError
____________________ test_module_docstring_security_warning ____________________

    def test_module_docstring_security_warning():
        """Verify that the module docstring also contains a security warning."""
>       assert "SECURITY" in code_exec.__doc__
E       assert 'SECURITY' in '\nCode Execution Mode - Anthropic "Code Mode" pattern implementation.\n\nWhen enabled, replaces 23 MCP tools with 3 b...rts and calls them. 98% token reduction.\n\nReference: https://www.anthropic.com/engineering/code-execution-with-mcp\n'
E        +  where '\nCode Execution Mode - Anthropic "Code Mode" pattern implementation.\n\nWhen enabled, replaces 23 MCP tools with 3 b...rts and calls them. 98% token reduction.\n\nReference: https://www.anthropic.com/engineering/code-execution-with-mcp\n' = code_exec.__doc__

/home/vmlinux/src/llmc/tests/mcp/test_code_exec_security.py:13: AssertionError
_____________________________ test_tool_is_renamed _____________________________

    def test_tool_is_renamed():
        """Verify that run_untrusted_python exists and execute_code is an alias to it."""
>       assert hasattr(code_exec, "run_untrusted_python")
E       AssertionError: assert False
E        +  where False = hasattr(code_exec, 'run_untrusted_python')

/home/vmlinux/src/llmc/tests/mcp/test_code_exec_security.py:19: AssertionError
_______________________________ test_mcp_via_sse _______________________________
async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted
__________________ test_all_tool_parameters_have_descriptions __________________

    def test_all_tool_parameters_have_descriptions():
        """
        Validates that every parameter in every tool's inputSchema has a description.
        """
        missing_descriptions = []
    
        for tool in TOOLS:
            schema = tool.inputSchema
            if "properties" in schema:
                for param, definition in schema["properties"].items():
                    if "description" not in definition or not definition["description"]:
                        missing_descriptions.append(f"{tool.name}.{param}")
    
>       assert not missing_descriptions, (
            "The following tool parameters are missing a 'description' field:\n"
            + "\n".join(missing_descriptions)
        )
E       AssertionError: The following tool parameters are missing a 'description' field:
E         linux_fs_write.mode
E         linux_fs_mkdir.exist_ok
E       assert not ['linux_fs_write.mode', 'linux_fs_mkdir.exist_ok']

/home/vmlinux/src/llmc/tests/mcp/test_tool_schemas.py:17: AssertionError
_________________________ test_execute_code_with_stubs _________________________

mcp_server = <llmc_mcp.server.LlmcMcpServer object at 0x74ccb67ae9c0>

    @pytest.mark.allow_sleep
    @pytest.mark.asyncio
    async def test_execute_code_with_stubs(mcp_server):
        # The server in "classic" mode does not generate stubs by default.
        # We need to trigger stub generation manually for this test.
        from llmc_mcp.tools.code_exec import generate_stubs
        stubs_dir = Path(mcp_server.config.code_execution.stubs_dir)
        llmc_root = Path(mcp_server.config.tools.allowed_roots[1])
        generate_stubs(mcp_server.tools, stubs_dir, llmc_root)
    
        test_file = Path("/tmp/test_execute_code_with_stubs.txt")
        test_content = "content from stubs test"
        test_file.write_text(test_content)
    
        code = f"""
    from stubs import read_file
    result = read_file(path='{test_file}')
    print(result['data'])
    """
        args = {"code": code}
        result = await mcp_server._handle_execute_code(args)
    
        assert result[0].text is not None
        data = json.loads(result[0].text)
>       assert data["success"] is True
E       assert False is True

/home/vmlinux/src/llmc/tests/rem_mcp_test.py:321: AssertionError
_______________ TestBoxxyAgent.test_agent_ask_with_tools_imports _______________

self = <test_boxxy_agent.TestBoxxyAgent object at 0x74ccb7ec3350>

    @pytest.mark.asyncio
    async def test_agent_ask_with_tools_imports(self):
        """
        Verify that Agent.ask_with_tools runs without import errors.
        This targets the circular import and type hint issues seen in static analysis.
        """
        # Use real Config object instead of mock
        config = Config()
        config.rag.enabled = False
        config.agent.model = "test-model"
    
        # We still need to mock the backend calls to avoid network/system calls
        agent = Agent(config)
        agent.ollama = MagicMock()
        agent.ollama.generate_with_tools = AsyncMock(
            return_value=MagicMock(
                content="I am Boxxy",
                tokens_prompt=10,
                tokens_completion=10,
                tool_calls=[],
                model="test-model",
            )
        )
    
        # Mock load_system_prompt to avoid file I/O
        with patch("llmc_agent.agent.load_system_prompt", return_value="System Prompt"):
>           response = await agent.ask_with_tools("Hello", session=None)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/home/vmlinux/src/llmc/tests/ruthless/test_boxxy_agent.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/vmlinux/src/llmc/llmc_agent/agent.py:358: in ask_with_tools
    parsed = parser.parse(response.raw_response or {})
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/vmlinux/src/llmc/llmc_agent/format/parsers/composite.py:45: in parse
    if parser.can_parse(response):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^
/home/vmlinux/src/llmc/llmc_agent/format/parsers/xml.py:41: in can_parse
    if re.search(pattern, content, re.DOTALL | re.IGNORECASE):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

pattern = '<tool_use>(.*?)</tool_use>'
string = <MagicMock name='mock.raw_response.content' id='128422586095552'>
flags = re.IGNORECASE|re.DOTALL

    def search(pattern, string, flags=0):
        """Scan through string looking for a match to the pattern, returning
        a Match object, or None if no match was found."""
>       return _compile(pattern, flags).search(string)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: expected string or bytes-like object, got 'MagicMock'

/usr/lib/python3.12/re/__init__.py:177: TypeError
_____________________ TestMcgrepCLI.test_mcgrep_help_works _____________________

self = <test_mcgrep_ruthless.TestMcgrepCLI object at 0x74ccb7d0b7d0>

    def test_mcgrep_help_works(self):
        """mcgrep --help should return usage info."""
        result = subprocess.run(
            [sys.executable, "-m", "llmc.mcgrep", "--help"],
            check=False,
            capture_output=True,
            text=True,
            timeout=10,
        )
>       assert result.returncode == 0
E       assert 1 == 0
E        +  where 1 = CompletedProcess(args=['/usr/bin/python3', '-m', 'llmc.mcgrep', '--help'], returncode=1, stdout='', stderr="/usr/bin/python3: Error while finding module specification for 'llmc.mcgrep' (ModuleNotFoundError: No module named 'llmc')\n").returncode

/home/vmlinux/src/llmc/tests/ruthless/test_mcgrep_ruthless.py:27: AssertionError
_______________ TestMcgrepCLI.test_mcgrep_status_command_exists ________________

self = <test_mcgrep_ruthless.TestMcgrepCLI object at 0x74ccb7d0bb60>

    def test_mcgrep_status_command_exists(self):
        """mcgrep status should be a valid command."""
        result = subprocess.run(
            [sys.executable, "-m", "llmc.mcgrep", "status", "--help"],
            check=False,
            capture_output=True,
            text=True,
            timeout=10,
        )
>       assert result.returncode == 0
E       assert 1 == 0
E        +  where 1 = CompletedProcess(args=['/usr/bin/python3', '-m', 'llmc.mcgrep', 'status', '--help'], returncode=1, stdout='', stderr="...n/python3: Error while finding module specification for 'llmc.mcgrep' (ModuleNotFoundError: No module named 'llmc')\n").returncode

/home/vmlinux/src/llmc/tests/ruthless/test_mcgrep_ruthless.py:42: AssertionError
_______________ TestMcgrepCLI.test_mcgrep_search_command_exists ________________

self = <test_mcgrep_ruthless.TestMcgrepCLI object at 0x74ccb7d283e0>

    def test_mcgrep_search_command_exists(self):
        """mcgrep search should be a valid command."""
        result = subprocess.run(
            [sys.executable, "-m", "llmc.mcgrep", "search", "--help"],
            check=False,
            capture_output=True,
            text=True,
            timeout=10,
        )
>       assert result.returncode == 0
E       assert 1 == 0
E        +  where 1 = CompletedProcess(args=['/usr/bin/python3', '-m', 'llmc.mcgrep', 'search', '--help'], returncode=1, stdout='', stderr="...n/python3: Error while finding module specification for 'llmc.mcgrep' (ModuleNotFoundError: No module named 'llmc')\n").returncode

/home/vmlinux/src/llmc/tests/ruthless/test_mcgrep_ruthless.py:54: AssertionError
__________ TestRuthlessMcgrep.test_mcgrep_run_search_with_long_lines ___________

query = 'query', path = None, limit = 1, show_summary = False

    def _run_search(query: str, path: str | None, limit: int, show_summary: bool) -> None:
        """Core search logic using embedding-based semantic search.
    
        Output format (hybrid):
        1. Top files: compact (FilePath "span-summary (proxy)" : Lstart-end[score])
        2. Remaining results: detailed (one span per line with summary)
        """
        from llmc.rag.search import search_spans
    
        try:
            repo_root = find_repo_root()
        except Exception:
            console.print("[red]Not in an LLMC-indexed repository.[/red]")
            console.print("Run: mcgrep init")
            raise typer.Exit(1)
    
        # Run embedding-based semantic search (has scoring fixes for filename matching)
        try:
            # Fetch many spans to ensure we get enough unique files
>           results = search_spans(query, limit=limit, repo_root=repo_root)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/home/vmlinux/src/llmc/llmc/mcgrep.py:423: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

query = 'query'

    def search_spans(
        query: str,
        *,
        limit: int = 5,
        repo_root: Path | None = None,
        model_override: str | None = None,
        debug: bool = False,
        tool_context: dict[str, Any] | None = None,
    ) -> list[SpanSearchResult]:
        """Execute a simple cosine-similarity search over the local `.rag` index."""
        repo = repo_root or find_repo_root()
        db_path = index_path_for_read(repo)
        if not db_path.exists():
>           raise FileNotFoundError(
                f"No embedding index found at {db_path}. Run `python -m llmc.rag.cli index` and `embed --execute` first."
            )
E           FileNotFoundError: No embedding index found at .rag/index.db. Run `python -m llmc.rag.cli index` and `embed --execute` first.

/home/vmlinux/src/llmc/llmc/rag/search/__init__.py:359: FileNotFoundError

During handling of the above exception, another exception occurred:

self = <test_rem_attack.TestRuthlessMcgrep object at 0x74ccb7dbf9b0>
capsys = <_pytest.capture.CaptureFixture object at 0x74ccb6a9ac30>

    def test_mcgrep_run_search_with_long_lines(self, capsys):
        """Test search with extremely long lines in snippet."""
        # Mock the tool_rag_search
        with patch("llmc.rag_nav.tool_handlers.tool_rag_search") as mock_search:
            with patch("llmc.mcgrep.find_repo_root") as mock_root:
                mock_root.return_value = Path(".")
    
                mock_item = MagicMock()
                mock_item.file = "long.py"
                mock_item.snippet.location.path = "long.py"
                mock_item.snippet.location.start_line = 1
                mock_item.snippet.location.end_line = 1
                # 1MB string
                mock_item.snippet.text = "A" * 1024 * 1024
    
                mock_result = MagicMock()
                mock_result.source = "RAG_GRAPH"
                mock_result.freshness_state = "FRESH"
                mock_result.items = [mock_item]
    
                mock_search.return_value = mock_result
    
>               _run_search("query", None, 1, False)

/home/vmlinux/src/llmc/tests/ruthless/test_rem_attack.py:67: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

query = 'query', path = None, limit = 1, show_summary = False

    def _run_search(query: str, path: str | None, limit: int, show_summary: bool) -> None:
        """Core search logic using embedding-based semantic search.
    
        Output format (hybrid):
        1. Top files: compact (FilePath "span-summary (proxy)" : Lstart-end[score])
        2. Remaining results: detailed (one span per line with summary)
        """
        from llmc.rag.search import search_spans
    
        try:
            repo_root = find_repo_root()
        except Exception:
            console.print("[red]Not in an LLMC-indexed repository.[/red]")
            console.print("Run: mcgrep init")
            raise typer.Exit(1)
    
        # Run embedding-based semantic search (has scoring fixes for filename matching)
        try:
            # Fetch many spans to ensure we get enough unique files
            results = search_spans(query, limit=limit, repo_root=repo_root)
        except FileNotFoundError:
            console.print("[red]No index found.[/red] Run: mcgrep watch")
>           raise typer.Exit(1)
E           click.exceptions.Exit: 1

/home/vmlinux/src/llmc/llmc/mcgrep.py:426: Exit
----------------------------- Captured stdout call -----------------------------
No index found. Run: mcgrep watch
___________ TestRuthlessMcgrep.test_mcgrep_invalid_result_structure ____________

query = 'query', path = None, limit = 1, show_summary = False

    def _run_search(query: str, path: str | None, limit: int, show_summary: bool) -> None:
        """Core search logic using embedding-based semantic search.
    
        Output format (hybrid):
        1. Top files: compact (FilePath "span-summary (proxy)" : Lstart-end[score])
        2. Remaining results: detailed (one span per line with summary)
        """
        from llmc.rag.search import search_spans
    
        try:
            repo_root = find_repo_root()
        except Exception:
            console.print("[red]Not in an LLMC-indexed repository.[/red]")
            console.print("Run: mcgrep init")
            raise typer.Exit(1)
    
        # Run embedding-based semantic search (has scoring fixes for filename matching)
        try:
            # Fetch many spans to ensure we get enough unique files
>           results = search_spans(query, limit=limit, repo_root=repo_root)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/home/vmlinux/src/llmc/llmc/mcgrep.py:423: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

query = 'query'

    def search_spans(
        query: str,
        *,
        limit: int = 5,
        repo_root: Path | None = None,
        model_override: str | None = None,
        debug: bool = False,
        tool_context: dict[str, Any] | None = None,
    ) -> list[SpanSearchResult]:
        """Execute a simple cosine-similarity search over the local `.rag` index."""
        repo = repo_root or find_repo_root()
        db_path = index_path_for_read(repo)
        if not db_path.exists():
>           raise FileNotFoundError(
                f"No embedding index found at {db_path}. Run `python -m llmc.rag.cli index` and `embed --execute` first."
            )
E           FileNotFoundError: No embedding index found at .rag/index.db. Run `python -m llmc.rag.cli index` and `embed --execute` first.

/home/vmlinux/src/llmc/llmc/rag/search/__init__.py:359: FileNotFoundError

During handling of the above exception, another exception occurred:

self = <test_rem_attack.TestRuthlessMcgrep object at 0x74ccb7ddeb70>
capsys = <_pytest.capture.CaptureFixture object at 0x74ccb69b23f0>

    def test_mcgrep_invalid_result_structure(self, capsys):
        """Test search when result structure is unexpected."""
        with patch("llmc.rag_nav.tool_handlers.tool_rag_search") as mock_search:
            with patch("llmc.mcgrep.find_repo_root") as mock_root:
                mock_root.return_value = Path(".")
    
                # Result missing 'items'
                mock_result = MagicMock()
                del mock_result.items
    
                mock_search.return_value = mock_result
    
                # Should not crash
>               _run_search("query", None, 1, False)

/home/vmlinux/src/llmc/tests/ruthless/test_rem_attack.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

query = 'query', path = None, limit = 1, show_summary = False

    def _run_search(query: str, path: str | None, limit: int, show_summary: bool) -> None:
        """Core search logic using embedding-based semantic search.
    
        Output format (hybrid):
        1. Top files: compact (FilePath "span-summary (proxy)" : Lstart-end[score])
        2. Remaining results: detailed (one span per line with summary)
        """
        from llmc.rag.search import search_spans
    
        try:
            repo_root = find_repo_root()
        except Exception:
            console.print("[red]Not in an LLMC-indexed repository.[/red]")
            console.print("Run: mcgrep init")
            raise typer.Exit(1)
    
        # Run embedding-based semantic search (has scoring fixes for filename matching)
        try:
            # Fetch many spans to ensure we get enough unique files
            results = search_spans(query, limit=limit, repo_root=repo_root)
        except FileNotFoundError:
            console.print("[red]No index found.[/red] Run: mcgrep watch")
>           raise typer.Exit(1)
E           click.exceptions.Exit: 1

/home/vmlinux/src/llmc/llmc/mcgrep.py:426: Exit
----------------------------- Captured stdout call -----------------------------
No index found. Run: mcgrep watch
__________ TestCLIIntegration.test_llmc_repo_validate_command_exists ___________

self = <test_repo_validator.TestCLIIntegration object at 0x74ccb7c0f080>

    @pytest.mark.integration
    @pytest.mark.allow_sleep
    def test_llmc_repo_validate_command_exists(self):
        """llmc repo validate should be a valid command."""
        import subprocess
        import sys
    
        result = subprocess.run(
            [sys.executable, "-m", "llmc.main", "repo", "validate", "--help"],
            check=False,
            capture_output=True,
            text=True,
            timeout=10,
        )
    
        # Command should exist
>       assert (
            result.returncode == 0
            or "validate" in result.stdout
            or "validate" in result.stderr
        )
E       assert (1 == 0 or 'validate' in '' or 'validate' in "/usr/bin/python3: Error while finding module specification for 'llmc.main' (ModuleNotFoundError: No module named 'llmc')\n")
E        +  where 1 = CompletedProcess(args=['/usr/bin/python3', '-m', 'llmc.main', 'repo', 'validate', '--help'], returncode=1, stdout='', ...bin/python3: Error while finding module specification for 'llmc.main' (ModuleNotFoundError: No module named 'llmc')\n").returncode
E        +  and   '' = CompletedProcess(args=['/usr/bin/python3', '-m', 'llmc.main', 'repo', 'validate', '--help'], returncode=1, stdout='', ...bin/python3: Error while finding module specification for 'llmc.main' (ModuleNotFoundError: No module named 'llmc')\n").stdout
E        +  and   "/usr/bin/python3: Error while finding module specification for 'llmc.main' (ModuleNotFoundError: No module named 'llmc')\n" = CompletedProcess(args=['/usr/bin/python3', '-m', 'llmc.main', 'repo', 'validate', '--help'], returncode=1, stdout='', ...bin/python3: Error while finding module specification for 'llmc.main' (ModuleNotFoundError: No module named 'llmc')\n").stderr

/home/vmlinux/src/llmc/tests/ruthless/test_repo_validator.py:278: AssertionError
_______________________ test_watcher_import_no_pyinotify _______________________

    def test_watcher_import_no_pyinotify():
        """
        Verify tools.rag.watcher imports correctly even if pyinotify is missing.
        This simulates the environment where pyinotify is not installed.
        """
        # Force pyinotify to be missing if it was somehow present
        with patch.dict(sys.modules, {"pyinotify": None}):
            # We need to reload or import checking logic
            # Since we modified the code to handle ImportError, we can just try importing
            try:
                from llmc.rag import watcher
    
>               assert not watcher.INOTIFY_AVAILABLE
E               AssertionError: assert not True
E                +  where True = <module 'llmc.rag.watcher' from '/home/vmlinux/src/llmc/llmc/rag/watcher.py'>.INOTIFY_AVAILABLE

/home/vmlinux/src/llmc/tests/ruthless/test_watcher_fix.py:19: AssertionError
_______________________ test_llmc_backend_injection_sync _______________________

    def test_llmc_backend_injection_sync():
        """Verify that user queries starting with - are treated as flags without -- delimiter."""
    
        async def run_test():
            from pathlib import Path
    
            repo_root = Path(__file__).parent.parent.parent
            print(f"Repo root: {repo_root}")
    
            backend = LLMCBackend(repo_root=repo_root)
    
            # We mock subprocess.run to capture arguments
            with patch("subprocess.run") as mock_run:
                # Configure mock to look like success
                mock_run.return_value.returncode = 0
                mock_run.return_value.stdout = '{"results": []}'
    
                # Attack query
                attack_query = "--help"
    
                await backend.search(attack_query)
    
                print(f"Mock calls: {mock_run.call_args_list}")
    
                if not mock_run.call_args:
                    pytest.fail(
                        f"subprocess.run was not called. Repo root found? {backend.repo_root}"
                    )
    
                # Check what was passed
                args, _ = mock_run.call_args
                cmd_list = args[0]
    
                # If safe, it should be [..., "search", "--", "--help", ...]
                # If unsafe, it is [..., "search", "--help", ...]
    
                # We expect it to be UNSAFE currently based on code review
                # We search for the index of "search"
                try:
                    search_idx = cmd_list.index("search")
                    # The next arg should be the query
                    next_arg = cmd_list[search_idx + 1]
    
                    if next_arg == "--":
                        pytest.fail("Vulnerability NOT found: '--' delimiter is present.")
                    elif next_arg == attack_query:
                        # Vulnerability confirmed
                        pass
                    else:
                        # Maybe arguments are shifted?
                        pass
                except ValueError:
                    pass
    
>       asyncio.run(run_test())

/home/vmlinux/src/llmc/tests/security/test_command_injection.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/asyncio/runners.py:193: in run
    with Runner(debug=debug, loop_factory=loop_factory) as runner:
/usr/lib/python3.12/asyncio/runners.py:58: in __enter__
    self._lazy_init()
/usr/lib/python3.12/asyncio/runners.py:137: in _lazy_init
    self._loop = events.new_event_loop()
                 ^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/asyncio/events.py:823: in new_event_loop
    return get_event_loop_policy().new_event_loop()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/asyncio/events.py:720: in new_event_loop
    return self._loop_factory()
           ^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/asyncio/unix_events.py:64: in __init__
    super().__init__(selector)
/usr/lib/python3.12/asyncio/selector_events.py:66: in __init__
    self._make_self_pipe()
/usr/lib/python3.12/asyncio/selector_events.py:120: in _make_self_pipe
    self._ssock, self._csock = socket.socketpair()
                               ^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/socket.py:610: in socketpair
    a = socket(family, type, proto, a.detach())
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tests._plugins.pytest_ruthless._NoNetSocket object at 0x74ccb6a872f0>
a = (<AddressFamily.AF_UNIX: 1>, <SocketKind.SOCK_STREAM: 1>, 0, 12), k = {}

    def __init__(self, *a, **k):
>       raise RuntimeError(
            "Network is blocked by pytest_ruthless. Use --allow-network or @pytest.mark.allow_network"
        )
E       RuntimeError: Network is blocked by pytest_ruthless. Use --allow-network or @pytest.mark.allow_network

/home/vmlinux/src/llmc/tests/_plugins/pytest_ruthless.py:37: RuntimeError
_________________________ test_poc_llmc_flag_injection _________________________

    @pytest.mark.asyncio
    async def test_poc_llmc_flag_injection():
        """
        POC: Flag Injection in LLMC Backend.
    
        The backend passes the query directly to subprocess without '--'.
        A query starting with '-' is interpreted as a flag.
        """
        print("\n[+] Testing LLMC Backend Flag Injection...")
    
        backend = LLMCBackend(repo_root=Path("."))
    
        # Mock _check_llmc_available to force fallback search (rg)
        backend._llmc_available = False  # Force fallback to rg
    
        with patch("subprocess.run") as mock_run:
            # Simulate searching for a flag-like string
            query = "--help"
    
            await backend._fallback_search(query, limit=5)
    
>           assert mock_run.called
E           AssertionError: assert False
E            +  where False = <MagicMock name='run' id='128422589012384'>.called

/home/vmlinux/src/llmc/tests/security/test_pocs.py:68: AssertionError
----------------------------- Captured stdout call -----------------------------

[+] Testing LLMC Backend Flag Injection...
________________ test_load_shell_backend_allows_path_traversal _________________

tmp_path = PosixPath('/tmp/pytest-of-vmlinux/pytest-57/test_load_shell_backend_allows0')

    def test_load_shell_backend_allows_path_traversal(tmp_path):
        """Verify that load_shell_backend allows executing scripts outside the repo."""
        repo_root = tmp_path / "repo"
        repo_root.mkdir()
    
        # Create a script OUTSIDE the repo
        outside_script = tmp_path / "evil_script.sh"
        outside_script.write_text("#!/bin/sh\necho 'owned'")
        outside_script.chmod(0o755)
    
        # Config pointing to the outside script using ..
        config = {"shell": {"script": "../evil_script.sh", "timeout_seconds": 10}}
    
        # This should succeed (but ideally shouldn't)
>       backend = load_shell_backend(repo_root, config)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/home/vmlinux/src/llmc/tests/test_docgen_ruthless_config.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

repo_root = PosixPath('/tmp/pytest-of-vmlinux/pytest-57/test_load_shell_backend_allows0/repo')
config = {'shell': {'script': '../evil_script.sh', 'timeout_seconds': 10}}

    def load_shell_backend(
        repo_root: Path,
        config: dict[str, Any],
    ) -> ShellDocgenBackend:
        """Load shell backend from configuration.
    
        Args:
            repo_root: Absolute path to repository root
            config: [docs.docgen] configuration section
    
        Returns:
            ShellDocgenBackend instance
    
        Raises:
            ValueError: If configuration is invalid
        """
        # Get shell-specific config
        shell_config = config.get("shell", {})
    
        # Get script path
        script_str = shell_config.get("script")
        if not script_str:
            raise ValueError("Missing 'shell.script' in docgen configuration")
    
        # Resolve script path (relative to repo root)
        script_path = (repo_root / script_str).resolve()
    
        # Security: ensure script is within repo root
        if not str(script_path).startswith(str(repo_root.resolve())):
>           raise ValueError(f"Docgen script is outside the repository root: {script_path}")
E           ValueError: Docgen script is outside the repository root: /tmp/pytest-of-vmlinux/pytest-57/test_load_shell_backend_allows0/evil_script.sh

/home/vmlinux/src/llmc/llmc/docgen/backends/shell.py:177: ValueError
______________________ test_enrich_aegis_repository_basic ______________________

tmp_path = PosixPath('/tmp/pytest-of-vmlinux/pytest-57/test_enrich_aegis_repository_b0')

    def test_enrich_aegis_repository_basic(tmp_path: Path) -> None:
        """Test basic enrichment of AEGIS repository."""
        if not AEGIS_REPO_PATH.exists():
            pytest.skip(f"AEGIS repository not found at {AEGIS_REPO_PATH}")
    
        # Setup: Copy AEGIS to test directory
        test_repo = tmp_path / "aegis_test"
        print(f"\n[*] Copying AEGIS repository to {test_repo}...")
        shutil.copytree(AEGIS_REPO_PATH, test_repo)
    
        # Ensure a fresh RAG workspace so index_repo performs real work.
        rag_dir = test_repo / ".rag"
        if rag_dir.exists():
            shutil.rmtree(rag_dir)
    
        # Note: index_repo uses find_repo_root() to detect the repo, so we need to run it from the test repo
        import os
    
        original_cwd = os.getcwd()
        try:
            os.chdir(test_repo)
            # The DB path is determined inside index_repo using index_path_for_write
            # which looks for .llmc/rag directory relative to the detected repo root
            print("[*] Indexing repository...")
    
            # Step 1: Index the repository
            stats = index_repo(include_paths=None, since=None)
    
            # Get the actual DB path that was created
            from llmc.rag.config import index_path_for_write
>           from llmc.rag.utils import find_repo_root
E           ImportError: cannot import name 'find_repo_root' from 'llmc.rag.utils' (/home/vmlinux/src/llmc/llmc/rag/utils.py)

/home/vmlinux/src/llmc/tests/test_enrichment_aegis_data.py:110: ImportError
----------------------------- Captured stdout call -----------------------------

[*] Copying AEGIS repository to /tmp/pytest-of-vmlinux/pytest-57/test_enrich_aegis_repository_b0/aegis_test...
[*] Indexing repository...
_______________________ test_enrich_aegis_data_integrity _______________________

tmp_path = PosixPath('/tmp/pytest-of-vmlinux/pytest-57/test_enrich_aegis_data_integri0')

    def test_enrich_aegis_data_integrity(tmp_path: Path) -> None:
        """Test data integrity of enriched AEGIS repository."""
        if not AEGIS_REPO_PATH.exists():
            pytest.skip(f"AEGIS repository not found at {AEGIS_REPO_PATH}")
    
        test_repo = tmp_path / "aegis_integrity"
        shutil.copytree(AEGIS_REPO_PATH, test_repo)
    
        # Ensure a clean workspace for integrity checks.
        rag_dir = test_repo / ".rag"
        if rag_dir.exists():
            shutil.rmtree(rag_dir)
    
        # Note: index_repo uses find_repo_root() to detect the repo, so we need to run it from the test repo
        import os
    
        original_cwd = os.getcwd()
        try:
            os.chdir(test_repo)
            from llmc.rag.config import index_path_for_write
>           from llmc.rag.utils import find_repo_root
E           ImportError: cannot import name 'find_repo_root' from 'llmc.rag.utils' (/home/vmlinux/src/llmc/llmc/rag/utils.py)

/home/vmlinux/src/llmc/tests/test_enrichment_aegis_data.py:359: ImportError
___ TestEnrichmentDataIntegrationSuccess.test_graph_has_enrichment_metadata ____

self = <test_enrichment_data_integration_failure.TestEnrichmentDataIntegrationSuccess object at 0x74ccb7a559a0>

    def test_graph_has_enrichment_metadata(self):
        """Verify that the graph JSON file contains enrichment data"""
        with open(self.graph_path) as f:
            graph = json.load(f)
    
        # Nav Graph structure: { "entities": [...], "relations": [...] }
        nodes = graph.get("entities", [])
    
>       assert len(nodes) > 0, "Graph should have nodes"
E       AssertionError: Graph should have nodes
E       assert 0 > 0
E        +  where 0 = len([])

/home/vmlinux/src/llmc/tests/test_enrichment_data_integration_failure.py:49: AssertionError
_________________ test_index_repo_creates_db_and_spans_export __________________

tmp_path = PosixPath('/tmp/pytest-of-vmlinux/pytest-57/test_index_repo_creates_db_and0')
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x74ccb67826c0>

    def test_index_repo_creates_db_and_spans_export(tmp_path: Path, monkeypatch) -> None:
        """index_repo on a minimal repo produces DB and spans export."""
        repo_root = tmp_path / "repo"
        repo_root.mkdir(parents=True, exist_ok=True)
        _write_simple_python_file(repo_root)
    
        # Run indexing with CWD set to the temporary repo.
        monkeypatch.chdir(repo_root)
    
>       stats = indexer.index_repo(export_json=True)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/home/vmlinux/src/llmc/tests/test_indexer_basic.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/vmlinux/src/llmc/llmc/rag/indexer.py:315: in index_repo
    source = absolute_path.read_bytes()
             ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/pathlib.py:1021: in read_bytes
    with self.open(mode='rb') as f:
         ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-vmlinux/pytest-57/test_graph_file_permission_err0/test_repo/.llmc/rag_graph.json')
mode = 'rb', buffering = -1, encoding = None, errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return io.open(self, mode, buffering, encoding, errors, newline)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       PermissionError: [Errno 13] Permission denied: '/tmp/pytest-of-vmlinux/pytest-57/test_graph_file_permission_err0/test_repo/.llmc/rag_graph.json'

/usr/lib/python3.12/pathlib.py:1015: PermissionError
------------------------------ Captured log call -------------------------------
ERROR    llmc.rag.sidecar:sidecar.py:336 Failed to convert pytest-of-vmlinux/pytest-57/test_is_sidecar_stale_outdated0/repo/doc.pdf: Failed to open file '/tmp/pytest-of-vmlinux/pytest-57/test_is_sidecar_stale_outdated0/repo/doc.pdf'.
____________________ test_index_repo_skips_unchanged_files _____________________

tmp_path = PosixPath('/tmp/pytest-of-vmlinux/pytest-57/test_index_repo_skips_unchange0')
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x74cca4172c30>

    def test_index_repo_skips_unchanged_files(tmp_path: Path, monkeypatch) -> None:
        """Second index_repo run should count unchanged file rather than reindexing."""
        repo_root = tmp_path / "repo"
        repo_root.mkdir(parents=True, exist_ok=True)
        _write_simple_python_file(repo_root)
    
        monkeypatch.chdir(repo_root)
    
>       first = indexer.index_repo(export_json=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/home/vmlinux/src/llmc/tests/test_indexer_basic.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/vmlinux/src/llmc/llmc/rag/indexer.py:315: in index_repo
    source = absolute_path.read_bytes()
             ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/pathlib.py:1021: in read_bytes
    with self.open(mode='rb') as f:
         ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-vmlinux/pytest-57/test_graph_file_permission_err0/test_repo/.llmc/rag_graph.json')
mode = 'rb', buffering = -1, encoding = None, errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return io.open(self, mode, buffering, encoding, errors, newline)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       PermissionError: [Errno 13] Permission denied: '/tmp/pytest-of-vmlinux/pytest-57/test_graph_file_permission_err0/test_repo/.llmc/rag_graph.json'

/usr/lib/python3.12/pathlib.py:1015: PermissionError
------------------------------ Captured log call -------------------------------
ERROR    llmc.rag.sidecar:sidecar.py:336 Failed to convert pytest-of-vmlinux/pytest-57/test_is_sidecar_stale_outdated0/repo/doc.pdf: Failed to open file '/tmp/pytest-of-vmlinux/pytest-57/test_is_sidecar_stale_outdated0/repo/doc.pdf'.
________ TestMCPHttpServerConfiguration.test_uses_config_host_and_port _________

self = <test_mcp_http_transport.TestMCPHttpServerConfiguration object at 0x74ccb7739760>

    def test_uses_config_host_and_port(self):
        """Server should use host/port from config."""
        from llmc_mcp.transport.http_server import MCPHttpServer
    
        mock_server = Mock()
        mock_server.tools = []
    
        mock_config = Mock()
        mock_config.server.host = "0.0.0.0"
        mock_config.server.port = 9999
        mock_config.server.transport = "http"
        mock_config.auth.mode = "none"
    
>       http = MCPHttpServer(mock_server, mock_config)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/home/vmlinux/src/llmc/tests/test_mcp_http_transport.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/vmlinux/src/llmc/llmc_mcp/transport/http_server.py:70: in __init__
    self.app = self._create_app()
               ^^^^^^^^^^^^^^^^^^
/home/vmlinux/src/llmc/llmc_mcp/transport/http_server.py:82: in _create_app
    app = Starlette(
/home/vmlinux/.local/lib/python3.12/site-packages/starlette/applications.py:69: in __init__
    self.router = Router(routes, on_startup=on_startup, on_shutdown=on_shutdown, lifespan=lifespan)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.routing.Router object at 0x74cca453ef60>
routes = [Route(path='/health', name='_health', methods=['GET', 'HEAD']), Route(path='/sse', name='_handle_sse', methods=['GET'...<bound method SseServerTransport.handle_post_message of <mcp.server.sse.SseServerTransport object at 0x74cca453d370>>)]
redirect_slashes = True, default = None
on_startup = [<bound method MCPHttpServer._on_startup of <llmc_mcp.transport.http_server.MCPHttpServer object at 0x74cca453d2b0>>]
on_shutdown = [<bound method MCPHttpServer._on_shutdown of <llmc_mcp.transport.http_server.MCPHttpServer object at 0x74cca453d2b0>>]
lifespan = None

    def __init__(
        self,
        routes: Sequence[BaseRoute] | None = None,
        redirect_slashes: bool = True,
        default: ASGIApp | None = None,
        on_startup: Sequence[Callable[[], Any]] | None = None,
        on_shutdown: Sequence[Callable[[], Any]] | None = None,
        # the generic to Lifespan[AppType] is the type of the top level application
        # which the router cannot know statically, so we use Any
        lifespan: Lifespan[Any] | None = None,
        *,
        middleware: Sequence[Middleware] | None = None,
    ) -> None:
        self.routes = [] if routes is None else list(routes)
        self.redirect_slashes = redirect_slashes
        self.default = self.not_found if default is None else default
        self.on_startup = [] if on_startup is None else list(on_startup)
        self.on_shutdown = [] if on_shutdown is None else list(on_shutdown)
    
        if on_startup or on_shutdown:
>           warnings.warn(
                "The on_startup and on_shutdown parameters are deprecated, and they "
                "will be removed on version 1.0. Use the lifespan parameter instead. "
                "See more about it on https://starlette.dev/lifespan/.",
                DeprecationWarning,
            )
E           DeprecationWarning: The on_startup and on_shutdown parameters are deprecated, and they will be removed on version 1.0. Use the lifespan parameter instead. See more about it on https://starlette.dev/lifespan/.

/home/vmlinux/.local/lib/python3.12/site-packages/starlette/routing.py:601: DeprecationWarning
__________ TestMCPHttpServerConfiguration.test_init_overrides_config ___________

self = <test_mcp_http_transport.TestMCPHttpServerConfiguration object at 0x74ccb7717770>

    def test_init_overrides_config(self):
        """Constructor args should override config."""
        from llmc_mcp.transport.http_server import MCPHttpServer
    
        mock_server = Mock()
        mock_server.tools = []
    
        mock_config = Mock()
        mock_config.server.host = "127.0.0.1"
        mock_config.server.port = 8080
        mock_config.server.transport = "http"
        mock_config.auth.mode = "none"
    
>       http = MCPHttpServer(mock_server, mock_config, host="192.168.1.1", port=3000)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/home/vmlinux/src/llmc/tests/test_mcp_http_transport.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/vmlinux/src/llmc/llmc_mcp/transport/http_server.py:70: in __init__
    self.app = self._create_app()
               ^^^^^^^^^^^^^^^^^^
/home/vmlinux/src/llmc/llmc_mcp/transport/http_server.py:82: in _create_app
    app = Starlette(
/home/vmlinux/.local/lib/python3.12/site-packages/starlette/applications.py:69: in __init__
    self.router = Router(routes, on_startup=on_startup, on_shutdown=on_shutdown, lifespan=lifespan)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.routing.Router object at 0x74cca453daf0>
routes = [Route(path='/health', name='_health', methods=['GET', 'HEAD']), Route(path='/sse', name='_handle_sse', methods=['GET'...<bound method SseServerTransport.handle_post_message of <mcp.server.sse.SseServerTransport object at 0x74cca453e870>>)]
redirect_slashes = True, default = None
on_startup = [<bound method MCPHttpServer._on_startup of <llmc_mcp.transport.http_server.MCPHttpServer object at 0x74cca453ec60>>]
on_shutdown = [<bound method MCPHttpServer._on_shutdown of <llmc_mcp.transport.http_server.MCPHttpServer object at 0x74cca453ec60>>]
lifespan = None

    def __init__(
        self,
        routes: Sequence[BaseRoute] | None = None,
        redirect_slashes: bool = True,
        default: ASGIApp | None = None,
        on_startup: Sequence[Callable[[], Any]] | None = None,
        on_shutdown: Sequence[Callable[[], Any]] | None = None,
        # the generic to Lifespan[AppType] is the type of the top level application
        # which the router cannot know statically, so we use Any
        lifespan: Lifespan[Any] | None = None,
        *,
        middleware: Sequence[Middleware] | None = None,
    ) -> None:
        self.routes = [] if routes is None else list(routes)
        self.redirect_slashes = redirect_slashes
        self.default = self.not_found if default is None else default
        self.on_startup = [] if on_startup is None else list(on_startup)
        self.on_shutdown = [] if on_shutdown is None else list(on_shutdown)
    
        if on_startup or on_shutdown:
>           warnings.warn(
                "The on_startup and on_shutdown parameters are deprecated, and they "
                "will be removed on version 1.0. Use the lifespan parameter instead. "
                "See more about it on https://starlette.dev/lifespan/.",
                DeprecationWarning,
            )
E           DeprecationWarning: The on_startup and on_shutdown parameters are deprecated, and they will be removed on version 1.0. Use the lifespan parameter instead. See more about it on https://starlette.dev/lifespan/.

/home/vmlinux/.local/lib/python3.12/site-packages/starlette/routing.py:601: DeprecationWarning
__________ TestMCPHttpServerConfiguration.test_creates_sse_transport ___________

self = <test_mcp_http_transport.TestMCPHttpServerConfiguration object at 0x74ccb7717620>

    def test_creates_sse_transport(self):
        """Server should create SSE transport."""
        from llmc_mcp.transport.http_server import MCPHttpServer
    
        mock_server = Mock()
        mock_server.tools = []
    
        mock_config = Mock()
        mock_config.server.host = "127.0.0.1"
        mock_config.server.port = 8080
    
>       http = MCPHttpServer(mock_server, mock_config)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/home/vmlinux/src/llmc/tests/test_mcp_http_transport.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/vmlinux/src/llmc/llmc_mcp/transport/http_server.py:70: in __init__
    self.app = self._create_app()
               ^^^^^^^^^^^^^^^^^^
/home/vmlinux/src/llmc/llmc_mcp/transport/http_server.py:82: in _create_app
    app = Starlette(
/home/vmlinux/.local/lib/python3.12/site-packages/starlette/applications.py:69: in __init__
    self.router = Router(routes, on_startup=on_startup, on_shutdown=on_shutdown, lifespan=lifespan)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.routing.Router object at 0x74cca45c8740>
routes = [Route(path='/health', name='_health', methods=['GET', 'HEAD']), Route(path='/sse', name='_handle_sse', methods=['GET'...<bound method SseServerTransport.handle_post_message of <mcp.server.sse.SseServerTransport object at 0x74cca45c8890>>)]
redirect_slashes = True, default = None
on_startup = [<bound method MCPHttpServer._on_startup of <llmc_mcp.transport.http_server.MCPHttpServer object at 0x74cca45cbd10>>]
on_shutdown = [<bound method MCPHttpServer._on_shutdown of <llmc_mcp.transport.http_server.MCPHttpServer object at 0x74cca45cbd10>>]
lifespan = None

    def __init__(
        self,
        routes: Sequence[BaseRoute] | None = None,
        redirect_slashes: bool = True,
        default: ASGIApp | None = None,
        on_startup: Sequence[Callable[[], Any]] | None = None,
        on_shutdown: Sequence[Callable[[], Any]] | None = None,
        # the generic to Lifespan[AppType] is the type of the top level application
        # which the router cannot know statically, so we use Any
        lifespan: Lifespan[Any] | None = None,
        *,
        middleware: Sequence[Middleware] | None = None,
    ) -> None:
        self.routes = [] if routes is None else list(routes)
        self.redirect_slashes = redirect_slashes
        self.default = self.not_found if default is None else default
        self.on_startup = [] if on_startup is None else list(on_startup)
        self.on_shutdown = [] if on_shutdown is None else list(on_shutdown)
    
        if on_startup or on_shutdown:
>           warnings.warn(
                "The on_startup and on_shutdown parameters are deprecated, and they "
                "will be removed on version 1.0. Use the lifespan parameter instead. "
                "See more about it on https://starlette.dev/lifespan/.",
                DeprecationWarning,
            )
E           DeprecationWarning: The on_startup and on_shutdown parameters are deprecated, and they will be removed on version 1.0. Use the lifespan parameter instead. See more about it on https://starlette.dev/lifespan/.

/home/vmlinux/.local/lib/python3.12/site-packages/starlette/routing.py:601: DeprecationWarning
__________ TestMCPHttpServerConfiguration.test_creates_starlette_app ___________

self = <test_mcp_http_transport.TestMCPHttpServerConfiguration object at 0x74ccb7706e70>

    def test_creates_starlette_app(self):
        """Server should create Starlette app with routes."""
        from llmc_mcp.transport.http_server import MCPHttpServer
    
        mock_server = Mock()
        mock_server.tools = []
    
        mock_config = Mock()
        mock_config.server.host = "127.0.0.1"
        mock_config.server.port = 8080
    
>       http = MCPHttpServer(mock_server, mock_config)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/home/vmlinux/src/llmc/tests/test_mcp_http_transport.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/vmlinux/src/llmc/llmc_mcp/transport/http_server.py:70: in __init__
    self.app = self._create_app()
               ^^^^^^^^^^^^^^^^^^
/home/vmlinux/src/llmc/llmc_mcp/transport/http_server.py:82: in _create_app
    app = Starlette(
/home/vmlinux/.local/lib/python3.12/site-packages/starlette/applications.py:69: in __init__
    self.router = Router(routes, on_startup=on_startup, on_shutdown=on_shutdown, lifespan=lifespan)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.routing.Router object at 0x74cca453fdd0>
routes = [Route(path='/health', name='_health', methods=['GET', 'HEAD']), Route(path='/sse', name='_handle_sse', methods=['GET'...<bound method SseServerTransport.handle_post_message of <mcp.server.sse.SseServerTransport object at 0x74cca453f7d0>>)]
redirect_slashes = True, default = None
on_startup = [<bound method MCPHttpServer._on_startup of <llmc_mcp.transport.http_server.MCPHttpServer object at 0x74cca453fa70>>]
on_shutdown = [<bound method MCPHttpServer._on_shutdown of <llmc_mcp.transport.http_server.MCPHttpServer object at 0x74cca453fa70>>]
lifespan = None

    def __init__(
        self,
        routes: Sequence[BaseRoute] | None = None,
        redirect_slashes: bool = True,
        default: ASGIApp | None = None,
        on_startup: Sequence[Callable[[], Any]] | None = None,
        on_shutdown: Sequence[Callable[[], Any]] | None = None,
        # the generic to Lifespan[AppType] is the type of the top level application
        # which the router cannot know statically, so we use Any
        lifespan: Lifespan[Any] | None = None,
        *,
        middleware: Sequence[Middleware] | None = None,
    ) -> None:
        self.routes = [] if routes is None else list(routes)
        self.redirect_slashes = redirect_slashes
        self.default = self.not_found if default is None else default
        self.on_startup = [] if on_startup is None else list(on_startup)
        self.on_shutdown = [] if on_shutdown is None else list(on_shutdown)
    
        if on_startup or on_shutdown:
>           warnings.warn(
                "The on_startup and on_shutdown parameters are deprecated, and they "
                "will be removed on version 1.0. Use the lifespan parameter instead. "
                "See more about it on https://starlette.dev/lifespan/.",
                DeprecationWarning,
            )
E           DeprecationWarning: The on_startup and on_shutdown parameters are deprecated, and they will be removed on version 1.0. Use the lifespan parameter instead. See more about it on https://starlette.dev/lifespan/.

/home/vmlinux/.local/lib/python3.12/site-packages/starlette/routing.py:601: DeprecationWarning
_____________ TestMedicalRAGIntegration.test_negation_detection_f1 _____________

self = <test_medical_integration.TestMedicalRAGIntegration object at 0x74ccb7784260>
sample_notes = [{'author': 'Dr. Smith', 'date': '2024-03-15', 'expected_negations': ['shortness of breath', 'nausea', 'myocardial inf...s', 'date': '2024-03-19', 'expected_negations': ['nighttime symptoms'], 'expected_phi': ['P-78905', 'Dr. Davis'], ...}]

    def test_negation_detection_f1(self, sample_notes):
        """
        Test negation detection with F1 target >= 0.90.
    
        Uses ClinicalRelationExtractor to identify negated conditions.
        """
        extractor = ClinicalRelationExtractor()
    
        true_positives = 0
        false_positives = 0
        false_negatives = 0
    
        for note in sample_notes:
            text = note.get("text", "")
            expected_negations = note.get("expected_negations", [])
    
            # Extract relations from text
            relations = extractor.extract_from_text(text)
    
            # Find negated conditions in extracted relations
            detected_negations = []
            for rel in relations:
                # Assuming relation type indicates negation
                if hasattr(rel, "relation_type") and "neg" in rel.relation_type.lower():
                    detected_negations.append(rel.condition.lower())
    
            # Compare with expected negations
            expected_lower = [n.lower() for n in expected_negations]
            detected_lower = [n.lower() for n in detected_negations]
    
            # Count metrics
            for neg in detected_lower:
                if neg in expected_lower:
                    true_positives += 1
                else:
                    false_positives += 1
    
            for neg in expected_lower:
                if neg not in detected_lower:
                    false_negatives += 1
    
        # Calculate precision, recall, and F1
        if (true_positives + false_positives) > 0:
            precision = true_positives / (true_positives + false_positives)
        else:
            precision = 1.0
    
        if (true_positives + false_negatives) > 0:
            recall = true_positives / (true_positives + false_negatives)
        else:
            recall = 1.0
    
        if (precision + recall) > 0:
            f1_score = 2 * (precision * recall) / (precision + recall)
        else:
            f1_score = 0.0
    
        print(
            f"Negation detection F1: {f1_score:.3f} (P={precision:.3f}, R={recall:.3f})"
        )
>       assert (
            f1_score >= 0.90
        ), f"Negation detection F1 {f1_score:.3f} below target 0.90"
E       AssertionError: Negation detection F1 0.000 below target 0.90
E       assert 0.0 >= 0.9

/home/vmlinux/src/llmc/tests/test_medical_integration.py:165: AssertionError
----------------------------- Captured stdout call -----------------------------
Negation detection F1: 0.000 (P=1.000, R=0.000)
_________________ TestMedicalRAGIntegration.test_phi_coverage __________________

self = <test_medical_integration.TestMedicalRAGIntegration object at 0x74ccb77846e0>
sample_notes = [{'author': 'Dr. Smith', 'date': '2024-03-15', 'expected_negations': ['shortness of breath', 'nausea', 'myocardial inf...s', 'date': '2024-03-19', 'expected_negations': ['nighttime symptoms'], 'expected_phi': ['P-78905', 'Dr. Davis'], ...}]

    def test_phi_coverage(self, sample_notes):
        """
        Test PHI coverage target >= 0.99.
    
        Uses PHI detector to identify protected health information.
        """
        # Mock PHI detector for testing
        # In a real implementation, this would use the actual PHI detector
        phi_patterns = [
            r"\b\d{3}-\d{2}-\d{4}\b",  # SSN
            r"\b\d{3}-\d{3}-\d{4}\b",  # Phone
            r"\b[A-Z][a-z]+ [A-Z][a-z]+\b",  # Name (simple)
            r"\b\d{1,2}/\d{1,2}/\d{4}\b",  # Date
            r"\b\d+\s+[A-Z][a-z]+\s+(St|Ave|Rd|Blvd)\b",  # Address
        ]
    
        import re
    
        total_phi_instances = 0
        detected_phi_instances = 0
    
        for note in sample_notes:
            text = note.get("text", "")
            expected_phi = note.get("expected_phi", [])
    
            # Count expected PHI
            total_phi_instances += len(expected_phi)
    
            # Detect PHI using patterns
            for phi_item in expected_phi:
                detected = False
                for pattern in phi_patterns:
                    if re.search(pattern, phi_item):
                        detected = True
                        break
                if detected:
                    detected_phi_instances += 1
    
        # Calculate coverage
        if total_phi_instances > 0:
            coverage = detected_phi_instances / total_phi_instances
        else:
            coverage = 1.0
    
        print(
            f"PHI coverage: {coverage:.3f} ({detected_phi_instances}/{total_phi_instances})"
        )
>       assert coverage >= 0.99, f"PHI coverage {coverage:.3f} below target 0.99"
E       AssertionError: PHI coverage 0.000 below target 0.99
E       assert 0.0 >= 0.99

/home/vmlinux/src/llmc/tests/test_medical_integration.py:216: AssertionError
----------------------------- Captured stdout call -----------------------------
PHI coverage: 0.000 (0/15)
___________________________ test_evaluation_metrics ____________________________

    def test_evaluation_metrics():
        """Test medical evaluation metrics."""
        evaluator = MedicalEvaluator()
    
        # Test data
        predictions = [
            ["doc2", "doc1", "doc3", "doc4"],
            ["doc1", "doc3", "doc5", "doc2"],
            ["doc4", "doc5", "doc6", "doc1"],
        ]
        ground_truth = [["doc1", "doc2"], ["doc1"], ["doc7", "doc8"]]
    
        # Test Recall@K
        recall_at_2 = evaluator.compute_recall_at_k(predictions, ground_truth, k=2)
        # For first query: top 2 are doc2, doc1 -> both relevant -> recall 1.0
        # Second query: top 2 are doc1, doc3 -> only doc1 relevant -> recall 0.5
        # Third query: top 2 are doc4, doc5 -> none relevant -> recall 0.0
        expected_recall_at_2 = (1.0 + 0.5 + 0.0) / 3
>       assert recall_at_2 == pytest.approx(expected_recall_at_2)
E       assert 0.6666666666666666 == 0.5  5.0e-07
E         
E         comparison failed
E         Obtained: 0.6666666666666666
E         Expected: 0.5  5.0e-07

/home/vmlinux/src/llmc/tests/test_medical_search.py:201: AssertionError
_______ TestPhase2EnrichmentIntegration.test_enriched_graph_has_metadata _______

self = <test_phase2_enrichment_integration.TestPhase2EnrichmentIntegration object at 0x74ccb761c200>

    def test_enriched_graph_has_metadata(self):
        """Test that build_enriched_schema_graph attaches enrichment metadata"""
        # Get a small sample of Python files for faster test
        file_paths = list(self.repo_root.glob("tools/rag/*.py"))[:5]
    
        # Build enriched graph
        graph = build_enriched_schema_graph(self.repo_root, self.db_path, file_paths)
    
        # Verify basic structure
>       assert len(graph.entities) > 0, "Graph should have entities"
E       AssertionError: Graph should have entities
E       assert 0 > 0
E        +  where 0 = len([])
E        +    where [] = SchemaGraph(version=1, indexed_at='2025-12-23T16:28:44.328543+00:00', repo='/home/vmlinux/src/llmc', entities=[], relations=[]).entities

/home/vmlinux/src/llmc/tests/test_phase2_enrichment_integration.py:32: AssertionError
__ TestPhase2EnrichmentIntegration.test_enriched_graph_preserves_ast_metadata __

self = <test_phase2_enrichment_integration.TestPhase2EnrichmentIntegration object at 0x74ccb761c650>

    def test_enriched_graph_preserves_ast_metadata(self):
        """Test that enrichment doesn't clobber existing AST metadata"""
        file_paths = list(self.repo_root.glob("tools/rag/*.py"))[:3]
        graph = build_enriched_schema_graph(self.repo_root, self.db_path, file_paths)
    
        # Find a function entity
        func_entities = [e for e in graph.entities if e.kind == "function"]
>       assert len(func_entities) > 0, "Should have function entities"
E       AssertionError: Should have function entities
E       assert 0 > 0
E        +  where 0 = len([])

/home/vmlinux/src/llmc/tests/test_phase2_enrichment_integration.py:65: AssertionError
____ TestPhase2EnrichmentIntegration.test_entity_location_fields_populated _____

self = <test_phase2_enrichment_integration.TestPhase2EnrichmentIntegration object at 0x74ccb761caa0>

    def test_entity_location_fields_populated(self):
        """Test that entities have file_path, start_line, end_line (Phase 2 additions)"""
        file_paths = list(self.repo_root.glob("tools/rag/database.py"))
        graph = build_enriched_schema_graph(self.repo_root, self.db_path, file_paths)
    
>       assert len(graph.entities) > 0, "Should have entities"
E       AssertionError: Should have entities
E       assert 0 > 0
E        +  where 0 = len([])
E        +    where [] = SchemaGraph(version=1, indexed_at='2025-12-23T16:28:51.265935+00:00', repo='/home/vmlinux/src/llmc', entities=[], relations=[]).entities

/home/vmlinux/src/llmc/tests/test_phase2_enrichment_integration.py:78: AssertionError
______ TestPhase2EnrichmentIntegration.test_enriched_graph_saves_to_json _______

self = <test_phase2_enrichment_integration.TestPhase2EnrichmentIntegration object at 0x74ccb761d340>

    def test_enriched_graph_saves_to_json(self):
        """Test that enriched graph can be saved and loaded from JSON"""
        file_paths = list(self.repo_root.glob("tools/rag/*.py"))[:5]
        graph = build_enriched_schema_graph(self.repo_root, self.db_path, file_paths)
    
        # Save to JSON
        graph.save(self.graph_output_path)
    
        # Load back
        with open(self.graph_output_path) as f:
            data = json.load(f)
    
        # Verify enrichment is in the JSON
        entities = data["entities"]
        enriched_in_json = [e for e in entities if "summary" in e.get("metadata", {})]
    
>       assert (
            len(enriched_in_json) > 0
        ), "Saved JSON should contain entities with enrichment metadata"
E       AssertionError: Saved JSON should contain entities with enrichment metadata
E       assert 0 > 0
E        +  where 0 = len([])

/home/vmlinux/src/llmc/tests/test_phase2_enrichment_integration.py:136: AssertionError
___________________________ test_phi_detector_basic ____________________________

    def test_phi_detector_basic():
        """Test basic PHI detection."""
        detector = PHIDetector()
    
        # Test SSN
        text = "Patient SSN is 123-45-6789."
        matches = detector.detect(text)
>       assert len(matches) == 1
E       AssertionError: assert 2 == 1
E        +  where 2 = len([(0, 14, 'NAME'), (15, 26, 'SSN')])

/home/vmlinux/src/llmc/tests/test_phi_filter.py:20: AssertionError
_______________________ test_phi_filter_name_surrogates ________________________

    def test_phi_filter_name_surrogates():
        """Test name surrogate replacement in PHI filter."""
        filter = PHIFilter()
    
        text = "Patient John Smith was seen with Jane Doe."
        filtered = filter.filter_text(text, shift_dates=False, surrogate_names=True)
    
        # Should contain surrogate placeholders
        assert "[NAME_" in filtered
        # Original names should not be present
        assert "John Smith" not in filtered
        assert "Jane Doe" not in filtered
    
        # The same name should appear consistently in multiple occurrences
        text2 = "John Smith and John Smith are the same person."
        filtered2 = filter.filter_text(text2, shift_dates=False, surrogate_names=True)
    
        # Count occurrences of the surrogate for John Smith
        # Since we're using the same filter instance, the mapping should be reused
        # Find all [NAME_X] patterns
        import re
    
        surrogates = re.findall(r"\[NAME_\d+\]", filtered2)
        # All should be the same surrogate
>       assert len(set(surrogates)) == 1
E       AssertionError: assert 3 == 1
E        +  where 3 = len({'[NAME_4]', '[NAME_5]', '[NAME_6]'})
E        +    where {'[NAME_4]', '[NAME_5]', '[NAME_6]'} = set(['[NAME_6]', '[NAME_5]', '[NAME_4]'])

/home/vmlinux/src/llmc/tests/test_phi_filter.py:176: AssertionError
__________________________ test_phi_filter_edge_cases __________________________

    def test_phi_filter_edge_cases():
        """Test edge cases and error handling."""
        detector = PHIDetector()
    
        # Empty text
        matches = detector.detect("")
        assert len(matches) == 0
    
        # Text with no PHI
        text = "The weather is nice today."
        matches = detector.detect(text)
>       assert len(matches) == 0
E       AssertionError: assert 2 == 0
E        +  where 2 = len([(0, 14, 'NAME'), (14, 25, 'NAME')])

/home/vmlinux/src/llmc/tests/test_phi_filter.py:190: AssertionError
______________________ test_qwen_enrich_batch_mypy_clean _______________________

    def test_qwen_enrich_batch_mypy_clean() -> None:
        """Ensure mypy passes on qwen_enrich_batch script."""
>       _run(
            [
                "mypy",
                "--ignore-missing-imports",
                "scripts/qwen_enrich_batch.py",
            ]
        )

/home/vmlinux/src/llmc/tests/test_qwen_enrich_batch_static.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cmd = ['mypy', '--ignore-missing-imports', 'scripts/qwen_enrich_batch.py']

    def _run(cmd: list[str]) -> None:
        """Run a subprocess command and fail the test on non-zero exit."""
        result = subprocess.run(cmd, check=False, cwd=str(REPO_ROOT))
>       assert (
            result.returncode == 0
        ), f"{' '.join(cmd)} failed with code {result.returncode}"
E       AssertionError: mypy --ignore-missing-imports scripts/qwen_enrich_batch.py failed with code 1
E       assert 1 == 0
E        +  where 1 = CompletedProcess(args=['mypy', '--ignore-missing-imports', 'scripts/qwen_enrich_batch.py'], returncode=1).returncode

/home/vmlinux/src/llmc/tests/test_qwen_enrich_batch_static.py:10: AssertionError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "/home/vmlinux/.local/bin/mypy", line 5, in <module>
    from mypy.__main__ import console_entry
ModuleNotFoundError: No module named 'mypy'
_________ TestEnrichedTools.test_tool_search_attaches_graph_enrichment _________

self = <test_rag_nav_enriched_tools.TestEnrichedTools object at 0x74ccb75517c0>
tmp_path = PosixPath('/tmp/pytest-of-vmlinux/pytest-57/test_tool_search_attaches_grap0')

    def test_tool_search_attaches_graph_enrichment(self, tmp_path):
        """Test that tool_rag_search attaches enrichment from graph nodes."""
        try:
            from llmc.rag_nav.models import (
                SearchItem,
                SearchResult,
                Snippet,
                SnippetLocation,
            )
            from llmc.rag_nav.tool_handlers import tool_rag_search
        except ImportError:
            pytest.fail("Modules not found")
    
        repo_root = tmp_path / "repo"
        repo_root.mkdir()
    
        # Mock dependencies
        # 1. Mock _compute_route to use RAG
        # 2. Mock fts_search to return a hit
        # 3. Mock _load_graph to return enriched nodes
    
        mock_route = MagicMock()
        mock_route.use_rag = True
        mock_route.freshness_state = "FRESH"
    
        mock_hit = MagicMock()
        mock_hit.file = "src/auth.py"
        mock_hit.start_line = 10
        mock_hit.end_line = 20
        mock_hit.text = "def login(): pass"
        mock_hit.score = 1.0
    
        # Graph nodes with metadata
        mock_nodes = [
            {
                "id": "auth.login",
                "path": "src/auth.py",
                "start_line": 10,
                "end_line": 20,
                "metadata": {
                    "summary": "Authenticates user",
                    "usage_guide": "Call with credentials",
                },
            }
        ]
    
        with (
            patch("llmc.rag_nav.tool_handlers._compute_route", return_value=mock_route),
            patch("llmc.rag_nav.tool_handlers.fts_search", return_value=[mock_hit]),
            patch(
                "llmc.rag_nav.tool_handlers._load_graph", return_value=(mock_nodes, [])
            ),
            patch("llmc.rag_nav.tool_handlers.load_rerank_weights", return_value={}),
            patch(
                "llmc.rag_nav.tool_handlers.rerank_hits",
                side_effect=lambda q, h, **k: h,
            ),
        ):  # Pass-through
            result = tool_rag_search(repo_root, "login")
    
            assert len(result.items) == 1
            item = result.items[0]
>           assert item.enrichment is not None
E           AssertionError: assert None is not None
E            +  where None = SearchItem(file='src/auth.py', snippet=Snippet(text='def login(): pass', location=SnippetLocation(path='src/auth.py', start_line=10, end_line=20)), enrichment=None).enrichment

/home/vmlinux/src/llmc/tests/test_rag_nav_enriched_tools.py:99: AssertionError
__________ TestEnrichedTools.test_tool_where_used_attaches_enrichment __________

self = <test_rag_nav_enriched_tools.TestEnrichedTools object at 0x74ccb7551c70>
tmp_path = PosixPath('/tmp/pytest-of-vmlinux/pytest-57/test_tool_where_used_attaches_0')

    def test_tool_where_used_attaches_enrichment(self, tmp_path):
        """Test that where-used attaches enrichment."""
        from llmc.rag_nav.tool_handlers import tool_rag_where_used
    
        repo_root = tmp_path / "repo"
    
        mock_route = MagicMock()
        mock_route.use_rag = True
        mock_route.freshness_state = "FRESH"
    
        # Graph: Caller -> Callee
        # We want to see enrichment on the 'Caller' (the usage)
        mock_nodes = [
            {
                "id": "main",
                "path": "src/main.py",
                "start_line": 1,
                "end_line": 10,
                "metadata": {"summary": "Main entrypoint"},
            },
            {"id": "login", "path": "src/auth.py"},
        ]
        # Edge: main calls login
        # But wait, 'where_used("login")' -> returns 'main' (upstream)
        # The current tool implementation uses 'where_used_files_from_index' which returns paths.
        # Then it builds items.
        # The Phase 3 plan says we should use the GRAPH traversal if possible, or map paths back to nodes.
    
        # Ideally tool_rag_where_used should look up the node for the result path.
    
        with (
            patch("llmc.rag_nav.tool_handlers._compute_route", return_value=mock_route),
            patch("llmc.rag_nav.tool_handlers.load_graph_indices"),
            patch(
                "llmc.rag_nav.tool_handlers.where_used_files_from_index",
                return_value=["src/main.py"],
            ),
            patch(
                "llmc.rag_nav.tool_handlers._load_graph", return_value=(mock_nodes, [])
            ),
        ):
            result = tool_rag_where_used(repo_root, "login")
    
            assert len(result.items) == 1
            item = result.items[0]
            # We expect the tool to have matched src/main.py to the node "main" (by path)
            # and attached the summary.
>           assert item.enrichment is not None
E           AssertionError: assert None is not None
E            +  where None = WhereUsedItem(file='src/main.py', snippet=Snippet(text='', location=SnippetLocation(path='src/main.py', start_line=1, end_line=1)), enrichment=None).enrichment

/home/vmlinux/src/llmc/tests/test_rag_nav_enriched_tools.py:149: AssertionError
________ TestRAGRouterTierDecision.test_decide_tier_validation_required ________

args = (<test_rag_router.TestRAGRouterTierDecision object at 0x74ccb75f2780>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tools.rag_router'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'tools' has no attribute 'rag_router'

/usr/lib/python3.12/pkgutil.py:528: AttributeError
_________ TestRAGRouterTierDecision.test_decide_tier_complex_reasoning _________

args = (<test_rag_router.TestRAGRouterTierDecision object at 0x74ccb7418ec0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tools.rag_router'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'tools' has no attribute 'rag_router'

/usr/lib/python3.12/pkgutil.py:528: AttributeError
___________ TestRAGRouterTierDecision.test_decide_tier_large_context ___________

args = (<test_rag_router.TestRAGRouterTierDecision object at 0x74ccb741b110>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tools.rag_router'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'tools' has no attribute 'rag_router'

/usr/lib/python3.12/pkgutil.py:528: AttributeError
______ TestRAGRouterTierDecision.test_decide_tier_simple_high_confidence _______

args = (<test_rag_router.TestRAGRouterTierDecision object at 0x74ccb741a840>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tools.rag_router'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'tools' has no attribute 'rag_router'

/usr/lib/python3.12/pkgutil.py:528: AttributeError
________ TestRAGRouterTierDecision.test_decide_tier_simple_no_codebase _________

args = (<test_rag_router.TestRAGRouterTierDecision object at 0x74ccb741a180>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tools.rag_router'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'tools' has no attribute 'rag_router'

/usr/lib/python3.12/pkgutil.py:528: AttributeError
_______ TestRAGRouterTierDecision.test_decide_tier_testing_routes_to_mid _______

args = (<test_rag_router.TestRAGRouterTierDecision object at 0x74ccb7419a60>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tools.rag_router'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'tools' has no attribute 'rag_router'

/usr/lib/python3.12/pkgutil.py:528: AttributeError
_____ TestRAGRouterTierDecision.test_decide_tier_bug_hunting_routes_to_mid _____

args = (<test_rag_router.TestRAGRouterTierDecision object at 0x74ccb7418f80>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tools.rag_router'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'tools' has no attribute 'rag_router'

/usr/lib/python3.12/pkgutil.py:528: AttributeError
__________ TestRAGRouterTierDecision.test_decide_tier_default_to_mid ___________

args = (<test_rag_router.TestRAGRouterTierDecision object at 0x74ccb741ba40>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tools.rag_router'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'tools' has no attribute 'rag_router'

/usr/lib/python3.12/pkgutil.py:528: AttributeError
________ TestRAGRouterCostEstimation.test_cost_estimation_local_is_free ________

args = (<test_rag_router.TestRAGRouterCostEstimation object at 0x74ccb741bb30>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tools.rag_router'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'tools' has no attribute 'rag_router'

/usr/lib/python3.12/pkgutil.py:528: AttributeError
__________ TestRAGRouterCostEstimation.test_cost_estimation_mid_tier ___________

args = (<test_rag_router.TestRAGRouterCostEstimation object at 0x74ccb74282c0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tools.rag_router'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'tools' has no attribute 'rag_router'

/usr/lib/python3.12/pkgutil.py:528: AttributeError
________ TestRAGRouterCostEstimation.test_cost_estimation_premium_tier _________

args = (<test_rag_router.TestRAGRouterCostEstimation object at 0x74ccb74286b0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tools.rag_router'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'tools' has no attribute 'rag_router'

/usr/lib/python3.12/pkgutil.py:528: AttributeError
___ TestRAGRouterCostEstimation.test_cost_estimate_includes_input_and_output ___

args = (<test_rag_router.TestRAGRouterCostEstimation object at 0x74ccb7428aa0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tools.rag_router'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'tools' has no attribute 'rag_router'

/usr/lib/python3.12/pkgutil.py:528: AttributeError
___________ TestRAGRouterRAGIntegration.test_analyze_query_with_rag ____________

args = (<test_rag_router.TestRAGRouterRAGIntegration object at 0x74ccb7428b90>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tools.rag_router'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'tools' has no attribute 'rag_router'

/usr/lib/python3.12/pkgutil.py:528: AttributeError
_______ TestRAGRouterRAGIntegration.test_analyze_query_fallback_on_error _______

args = (<test_rag_router.TestRAGRouterRAGIntegration object at 0x74ccb7428ef0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tools.rag_router'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'tools' has no attribute 'rag_router'

/usr/lib/python3.12/pkgutil.py:528: AttributeError
________ TestRAGRouterRAGIntegration.test_decide_tier_gets_rag_results _________

args = (<test_rag_router.TestRAGRouterRAGIntegration object at 0x74ccb74292e0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tools.rag_router'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'tools' has no attribute 'rag_router'

/usr/lib/python3.12/pkgutil.py:528: AttributeError
________ TestRAGRouterRAGIntegration.test_decide_tier_no_rag_for_local _________

args = (<test_rag_router.TestRAGRouterRAGIntegration object at 0x74ccb74296d0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tools.rag_router'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'tools' has no attribute 'rag_router'

/usr/lib/python3.12/pkgutil.py:528: AttributeError
___________ TestRAGRouterRouteMethod.test_route_with_forced_routing ____________

args = (<test_rag_router.TestRAGRouterRouteMethod object at 0x74ccb7418260>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tools.rag_router'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'tools' has no attribute 'rag_router'

/usr/lib/python3.12/pkgutil.py:528: AttributeError
____________ TestRAGRouterRouteMethod.test_route_with_rag_analysis _____________

args = (<test_rag_router.TestRAGRouterRouteMethod object at 0x74ccb7418110>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tools.rag_router'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'tools' has no attribute 'rag_router'

/usr/lib/python3.12/pkgutil.py:528: AttributeError
______ TestRouteQueryConvenienceFunction.test_route_query_creates_router _______

args = (<test_rag_router.TestRouteQueryConvenienceFunction object at 0x74ccb7429850>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tools.rag_router'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'tools' has no attribute 'rag_router'

/usr/lib/python3.12/pkgutil.py:528: AttributeError
__ TestRouteQueryConvenienceFunction.test_route_query_auto_detects_repo_root ___

args = (<test_rag_router.TestRouteQueryConvenienceFunction object at 0x74ccb74293d0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tools.rag_router'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'tools' has no attribute 'rag_router'

/usr/lib/python3.12/pkgutil.py:528: AttributeError
________ TestRouteQueryConvenienceFunction.test_route_query_calls_route ________

args = (<test_rag_router.TestRouteQueryConvenienceFunction object at 0x74ccb74288c0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tools.rag_router'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'tools' has no attribute 'rag_router'

/usr/lib/python3.12/pkgutil.py:528: AttributeError
_______ TestRAGRouterErrorHandling.test_analyze_query_handles_empty_plan _______

args = (<test_rag_router.TestRAGRouterErrorHandling object at 0x74ccb7429c40>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tools.rag_router'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'tools' has no attribute 'rag_router'

/usr/lib/python3.12/pkgutil.py:528: AttributeError
____ TestRAGRouterErrorHandling.test_analyze_query_handles_malformed_spans _____

args = (<test_rag_router.TestRAGRouterErrorHandling object at 0x74ccb7429fa0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tools.rag_router'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'tools' has no attribute 'rag_router'

/usr/lib/python3.12/pkgutil.py:528: AttributeError
___ TestRAGRouterErrorHandling.test_decide_tier_handles_missing_rag_results ____

args = (<test_rag_router.TestRAGRouterErrorHandling object at 0x74ccb742a390>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tools.rag_router'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'tools' has no attribute 'rag_router'

/usr/lib/python3.12/pkgutil.py:528: AttributeError
_________ TestRAGRouterEdgeCases.test_multiple_forced_routing_matches __________

args = (<test_rag_router.TestRAGRouterEdgeCases object at 0x74ccb742b410>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tools.rag_router'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'tools' has no attribute 'rag_router'

/usr/lib/python3.12/pkgutil.py:528: AttributeError
____________ TestRAGRouterEdgeCases.test_context_token_calculation _____________

args = (<test_rag_router.TestRAGRouterEdgeCases object at 0x74ccb741a5a0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tools.rag_router'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'tools' has no attribute 'rag_router'

/usr/lib/python3.12/pkgutil.py:528: AttributeError
______________________ test_score_normalization_clamping _______________________

    def test_score_normalization_clamping():
        # Test that filename boost doesn't exceed 100.0
        # Query: "test"
        # File: "test.py" -> Boost 0.20
        # Vector: Exact match (1.0)
        # Raw Score: 1.20
        # Normalized: Should be clamped to 100.0
    
        query_vec = [1.0, 0.0]
        query_norm = 1.0
    
        candidates = [
            {
                "vec": _pack_vector([1.0, 0.0]),
                "span_hash": "h_boost",
                "file_path": "test.py",  # Matches query "test"
                "symbol": "s_boost",
                "kind": "def",
                "start_line": 1,
                "end_line": 10,
                "summary": "boosted",
            }
        ]
    
        results = _score_candidates(query_vec, query_norm, candidates, query_text="test")
    
        assert len(results) == 1
        r = results[0]
    
        # Raw score should include boost
        assert r.score > 1.0
        # 1.0 (cosine) + 0.15 (stem match) - 0.08 (test penalty) = 1.07
>       assert r.score == pytest.approx(1.07, 0.001)
E       assert 1.2 == 1.07  0.00107
E         
E         comparison failed
E         Obtained: 1.2
E         Expected: 1.07  0.00107

/home/vmlinux/src/llmc/tests/test_rag_score_normalization.py:119: AssertionError
__________________ TestRagRefresh.test_passes_args_to_runner ___________________

self = <test_refresh_sync_cron_scripts.TestRagRefresh object at 0x74ccb7450e90>

    def test_passes_args_to_runner(self):
        """Test that script passes arguments to Python runner."""
        script_path = Path(__file__).parent.parent / "scripts" / "rag_refresh.sh"
        with open(script_path) as f:
            content = f.read()
    
        # Should exec to Python runner with args
>       assert "llmc.rag.runner refresh" in content
E       assert 'llmc.rag.runner refresh' in '#!/usr/bin/env bash\nset -euo pipefail\n\nSCRIPT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"\nPYTHON_BIN=....venv/bin/python"\n  else\n    PYTHON_BIN="python3"\n  fi\nfi\n\nexec "$PYTHON_BIN" -m tools.rag.runner refresh "$@"\n'

/home/vmlinux/src/llmc/tests/test_refresh_sync_cron_scripts.py:74: AssertionError
__________________ test_scheduler_run_tick_with_mixed_states ___________________

tmp_path = PosixPath('/tmp/pytest-of-vmlinux/pytest-57/test_scheduler_run_tick_with_m0')

    def test_scheduler_run_tick_with_mixed_states(tmp_path: Path) -> None:
        """Scheduler tick correctly filters repos based on eligibility."""
        cfg = make_config(tmp_path)
    
        # Create repos
        repo_new = RepoDescriptor(
            repo_id="repo-new",
            repo_path=tmp_path / "repo1",
            rag_workspace_path=tmp_path / "repo1/.llmc/rag",
        )
        repo_running = RepoDescriptor(
            repo_id="repo-running",
            repo_path=tmp_path / "repo2",
            rag_workspace_path=tmp_path / "repo2/.llmc/rag",
        )
        repo_failed = RepoDescriptor(
            repo_id="repo-failed",
            repo_path=tmp_path / "repo3",
            rag_workspace_path=tmp_path / "repo3/.llmc/rag",
        )
        repo_success = RepoDescriptor(
            repo_id="repo-success",
            repo_path=tmp_path / "repo4",
            rag_workspace_path=tmp_path / "repo4/.llmc/rag",
        )
        repo_cooldown = RepoDescriptor(
            repo_id="repo-cooldown",
            repo_path=tmp_path / "repo5",
            rag_workspace_path=tmp_path / "repo5/.llmc/rag",
        )
    
        registry = DummyRegistry(
            {
                "repo-new": repo_new,
                "repo-running": repo_running,
                "repo-failed": repo_failed,
                "repo-success": repo_success,
                "repo-cooldown": repo_cooldown,
            }
        )
    
        workers = DummyWorkers()
    
        scheduler = Scheduler(cfg, registry, None, workers)
    
        now = datetime.now(UTC)
    
        # Create states
        states = {
            "repo-running": RepoState(repo_id="repo-running", last_run_status="running"),
            "repo-failed": RepoState(
                repo_id="repo-failed",
                last_run_status="error",
                consecutive_failures=3,  # Max failures
            ),
            "repo-success": RepoState(
                repo_id="repo-success",
                last_run_status="success",
                last_run_finished_at=now - timedelta(minutes=2),  # Old enough
            ),
            "repo-cooldown": RepoState(
                repo_id="repo-cooldown",
                last_run_status="error",
                next_eligible_at=now + timedelta(seconds=300),  # In future
            ),
        }
    
        # Mock the control and state store
>       with patch("tools.rag_daemon.scheduler.read_control_events") as mock_control:

/home/vmlinux/src/llmc/tests/test_scheduler_eligibility_comprehensive.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tools.rag_daemon.scheduler'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'tools' has no attribute 'rag_daemon'

/usr/lib/python3.12/pkgutil.py:528: AttributeError
___________________ test_scheduler_run_tick_with_force_flags ___________________

tmp_path = PosixPath('/tmp/pytest-of-vmlinux/pytest-57/test_scheduler_run_tick_with_f0')

    def test_scheduler_run_tick_with_force_flags(tmp_path: Path) -> None:
        """Force flags override eligibility checks."""
        cfg = make_config(tmp_path)
    
        repo = RepoDescriptor(
            repo_id="repo-force",
            repo_path=tmp_path / "repo",
            rag_workspace_path=tmp_path / "repo/.llmc/rag",
        )
    
        registry = DummyRegistry({"repo-force": repo})
    
        workers = DummyWorkers()
    
        scheduler = Scheduler(cfg, registry, None, workers)
    
        now = datetime.now(UTC)
        future_time = now + timedelta(seconds=300)
    
        states = {
            "repo-force": RepoState(
                repo_id="repo-force",
                last_run_status="error",
                consecutive_failures=3,  # Max failures
                next_eligible_at=future_time,
            )
        }
    
        # Test with refresh_all flag
>       with patch("tools.rag_daemon.scheduler.read_control_events") as mock_control:

/home/vmlinux/src/llmc/tests/test_scheduler_eligibility_comprehensive.py:392: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tools.rag_daemon.scheduler'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'tools' has no attribute 'rag_daemon'

/usr/lib/python3.12/pkgutil.py:528: AttributeError
_________________ test_search_command_uses_correct_attributes __________________

    def test_search_command_uses_correct_attributes():
        """Verify search command uses correct SpanSearchResult attributes.
    
        Regression test for P0 bug where .file_path and .text were used
        instead of .path and .summary.
        """
        # Create mock results with correct attributes
        mock_results = [
            SpanSearchResult(
                span_hash="sha256:abc123",
                path=Path("test/file.py"),
                symbol="test_function",
                kind="function",
                start_line=10,
                end_line=20,
                score=0.95,
                summary="Test function for authentication",
                normalized_score=0.95,
                debug_info=None,
            ),
            SpanSearchResult(
                span_hash="sha256:def456",
                path=Path("src/auth.py"),
                symbol="validate_token",
                kind="function",
                start_line=50,
                end_line=75,
                score=0.88,
                summary="Validates JWT tokens",
                normalized_score=0.88,
                debug_info=None,
            ),
        ]
    
        # Mock the search function
>       with patch("llmc.commands.rag.run_search_spans", return_value=mock_results):

/home/vmlinux/src/llmc/tests/test_search_command_regression.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x74cb1980ac90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'llmc.commands.rag' from '/home/vmlinux/src/llmc/llmc/commands/rag.py'> does not have the attribute 'run_search_spans'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
=============================== warnings summary ===============================
scripts/test_metrics_capture.py::test_metrics_capture_function
  /home/vmlinux/.local/lib/python3.12/site-packages/_pytest/python.py:170: PytestReturnNotNoneWarning: Test functions should return None, but scripts/test_metrics_capture.py::test_metrics_capture_function returned <class 'int'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/security/test_critical_pocs.py::test_te_cli_no_shell_injection
  /usr/lib/python3.12/unittest/mock.py:2129: RuntimeWarning: coroutine 'test_llmc_backend_injection_sync.<locals>.run_test' was never awaited
    if getattr(self, "_mock_methods", None) is not None:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/security/test_critical_pocs.py::test_te_cli_no_shell_injection
  /home/vmlinux/.local/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: PytestUnraisableExceptionWarning: Exception ignored in: <function BaseEventLoop.__del__ at 0x74cd0ea116c0>
  
  Traceback (most recent call last):
    File "/usr/lib/python3.12/asyncio/base_events.py", line 728, in __del__
      self.close()
    File "/usr/lib/python3.12/asyncio/unix_events.py", line 68, in close
      super().close()
    File "/usr/lib/python3.12/asyncio/selector_events.py", line 104, in close
      self._close_self_pipe()
    File "/usr/lib/python3.12/asyncio/selector_events.py", line 111, in _close_self_pipe
      self._remove_reader(self._ssock.fileno())
                          ^^^^^^^^^^^
  AttributeError: '_UnixSelectorEventLoop' object has no attribute '_ssock'
  
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
SKIPPED [1] tests/test_rag_repo_integration_edge_cases.py:28: Legacy RAG repo integration API not present; skipping edge-case tests
SKIPPED [1] tests/REPORTS/archive/adversarial_enrichment_test.py: Standalone test script - run directly with python
SKIPPED [1] tests/REPORTS/archive/adversarial_routing_test.py: Standalone test script - run directly with python
SKIPPED [4] tests/cli/test_mcread.py: Pre-existing test failures
SKIPPED [1] tests/gap/security/test_cmd_allowlist_config.py:7: Known security gap - allowlist is not yet implemented
SKIPPED [1] tests/gap/security/test_hybrid_mode.py:28: Known gap in implementation
SKIPPED [1] tests/gap/security/test_hybrid_mode.py:55: Known gap in implementation
SKIPPED [1] tests/gap/security/test_mcp_edit_oom.py:9: Known gap in implementation
SKIPPED [5] tests/mcp/manual_mcp_test.py: Standalone test script - run directly with python
SKIPPED [7] tests/mcp/test_fs.py: Standalone test script - run directly with python
SKIPPED [1] tests/mcp/test_mcp_http.py: Standalone test script - run directly with python
SKIPPED [20] tests/mcp/test_observability.py: Standalone test script - run directly with python
SKIPPED [4] tests/mcp/test_rag.py: Standalone test script - run directly with python
SKIPPED [7] tests/mcp/test_smoke.py: Standalone test script - run directly with python
SKIPPED [2] tests/mcp/test_tools_visibility_and_metrics.py:25: No accessible tool registry on server module.
SKIPPED [1] tests/rag/ci/test_llmc_docs_validation.py:79: roadmap.md not found
SKIPPED [1] tests/rag/ci/test_llmc_docs_validation.py:112: roadmap.md not found
SKIPPED [1] tests/rmta_gemini_test.py: Standalone test script - run directly with python
SKIPPED [1] tests/ruthless/test_cli_absolute_path_integration.py: Standalone test script - run directly with python
SKIPPED [1] tests/ruthless/test_ren_offensive.py:41: EnrichmentProviderConfig not found
SKIPPED [1] tests/ruthless/test_ren_offensive.py:102: GraphContextBuilder not found
SKIPPED [1] tests/ruthless/test_ren_offensive.py:139: DocgenLock not found
SKIPPED [1] tests/security/VULN-001/test_vuln_001.py: Standalone test script - run directly with python
SKIPPED [1] tests/security/test_mcp_shell.py: Standalone test script - run directly with python
SKIPPED [2] tests/security/test_ruta_bypass.py: Standalone test script - run directly with python
SKIPPED [1] tests/security/test_te_injection.py: Standalone test script - run directly with python
SKIPPED [5] tests/test_bug_sweep_highpriority.py: Standalone test script - run directly with python
SKIPPED [1] tests/test_code_first_fix.py: Standalone test script - run directly with python
SKIPPED [1] tests/test_file_mtime_guard.py:33: mtime guard not yet implemented
SKIPPED [1] tests/test_file_mtime_guard.py:53: mtime guard not yet implemented
SKIPPED [1] tests/test_file_mtime_guard.py:73: mtime guard not yet implemented
SKIPPED [1] tests/test_file_mtime_guard.py:102: mtime guard not yet implemented
SKIPPED [1] tests/test_file_mtime_guard.py:114: mtime guard not yet implemented
SKIPPED [1] tests/test_file_mtime_guard.py:127: mtime guard not yet implemented
SKIPPED [1] tests/test_file_mtime_guard.py:149: mtime guard not yet implemented
SKIPPED [1] tests/test_file_mtime_guard.py:171: mtime guard not yet implemented
SKIPPED [1] tests/test_file_mtime_guard.py:194: mtime guard not yet implemented
SKIPPED [1] tests/test_file_mtime_guard.py:229: mtime guard not yet implemented
SKIPPED [1] tests/test_file_mtime_guard.py:272: mtime guard not yet implemented
SKIPPED [1] tests/test_file_mtime_guard.py:283: mtime guard not yet implemented
SKIPPED [4] tests/test_idle_loop_throttling.py: Standalone test script - run directly with python
SKIPPED [1] tests/test_mcp_http_transport.py:143: Could not create real server: The on_startup and on_shutdown parameters are deprecated, and they will be removed on version 1.0. Use the lifespan parameter instead. See more about it on https://starlette.dev/lifespan/.
SKIPPED [1] tests/test_medical_integration.py:229: RAG database not found. Run indexing first.
SKIPPED [10] tests/test_multiple_registry_entries.py: Standalone test script - run directly with python
SKIPPED [1] tests/test_nav_tools_integration.py:246: Navigation tools not yet integrated with RagResult
SKIPPED [1] tests/test_nav_tools_integration.py:283: Navigation tools not yet integrated with RagResult
SKIPPED [1] tests/test_nav_tools_integration.py:314: Navigation tools not yet integrated with RagResult
SKIPPED [1] tests/test_nav_tools_integration.py:343: CLI integration not yet implemented
SKIPPED [1] tests/test_nav_tools_integration.py:362: CLI integration not yet implemented
SKIPPED [1] tests/test_ollama_live.py:39: Ollama server unreachable: HTTP is blocked by pytest_ruthless. Use --allow-network or @pytest.mark.allow_network
SKIPPED [6] tests/test_rag_failures.py: Standalone test script - run directly with python
SKIPPED [7] tests/test_remote_providers.py: Standalone test script - run directly with python
SKIPPED [12] tests/test_repo_add_idempotency.py: Standalone test script - run directly with python
SKIPPED [1] tests/test_resilient_rag.py: _attach_graph_enrichment removed in v0.8.0; enrichment now uses SQLite-based attach
SKIPPED [1] tests/test_rmta_rag_nav_fix.py: Standalone test script - run directly with python
SKIPPED [1] tests/test_schema_typescript_integration.py: Standalone test script - run directly with python
SKIPPED [1] tests/test_telemetry_sqlite.py: Standalone test script - run directly with python
SKIPPED [10] tests/test_wrapper_scripts.py: Personal wrapper scripts - not part of production code
ERROR tests/test_mcp_http_transport.py::TestMCPHttpServerRoutes::test_health_route_exists
ERROR tests/test_mcp_http_transport.py::TestMCPHttpServerRoutes::test_sse_route_exists
ERROR tests/test_mcp_http_transport.py::TestMCPHttpServerRoutes::test_messages_route_exists
FAILED llmc/commands/test_mcp.py::test_mcp - click.exceptions.Exit: 1
FAILED llmc/rag/extractors/test_context_detector.py::test_detect_context_family
FAILED llmc/rag/extractors/test_context_detector.py::test_detect_context_multiple_categories
FAILED llmc/rag/tests/test_scoring.py::TestScorer::test_load_defaults - asser...
FAILED llmc/rag/tests/test_scoring.py::TestScorer::test_score_extension_neutral
FAILED llmc/rag/tests/test_scoring.py::TestScorer::test_score_filename_match
FAILED llmc/rag/tests/test_search_eval_canary.py::test_search_eval_harness_runs_and_prefers_rag
FAILED tests/gap/test_agent_context_overflow.py::TestAgentContextOverflow::test_unbounded_tool_output_context_overflow
FAILED tests/gap/test_agent_robustness.py::test_agent_handles_malformed_json_tool_args
FAILED tests/gap/test_agent_tool_feedback.py::TestAgentToolFeedback::test_silent_tool_failure_feedback
FAILED tests/gap/test_mcp_dos.py::test_dos_via_exit - Failed: DID NOT RAISE <...
FAILED tests/gap/test_mcp_dos.py::test_dos_via_keyboard_interrupt - Failed: D...
FAILED tests/gap/test_mcp_fs_devices.py::test_write_file_append_blocks_fifo
FAILED tests/gap/test_router_resilience.py::test_router_resilience_heuristic_failure
FAILED tests/main/test_main.py::test_chat_shell_injection - AssertionError: S...
FAILED tests/main/test_main.py::test_chat_xss_injection - AssertionError: XSS...
FAILED tests/main/test_main.py::test_chat_sql_injection - AssertionError: SQL...
FAILED tests/mcp/test_code_exec.py::TestExecuteCode::test_call_tool_injection
FAILED tests/mcp/test_code_exec.py::TestExecuteCode::test_import_stub_calls_injected_tool
FAILED tests/mcp/test_code_exec.py::TestExecuteCode::test_timeout_capture - a...
FAILED tests/mcp/test_code_exec_security.py::test_run_untrusted_python_security_warning
FAILED tests/mcp/test_code_exec_security.py::test_module_docstring_security_warning
FAILED tests/mcp/test_code_exec_security.py::test_tool_is_renamed - Assertion...
FAILED tests/mcp/test_mcp_sse.py::test_mcp_via_sse - Failed: async def functi...
FAILED tests/mcp/test_tool_schemas.py::test_all_tool_parameters_have_descriptions
FAILED tests/rem_mcp_test.py::test_execute_code_with_stubs - assert False is ...
FAILED tests/ruthless/test_boxxy_agent.py::TestBoxxyAgent::test_agent_ask_with_tools_imports
FAILED tests/ruthless/test_mcgrep_ruthless.py::TestMcgrepCLI::test_mcgrep_help_works
FAILED tests/ruthless/test_mcgrep_ruthless.py::TestMcgrepCLI::test_mcgrep_status_command_exists
FAILED tests/ruthless/test_mcgrep_ruthless.py::TestMcgrepCLI::test_mcgrep_search_command_exists
FAILED tests/ruthless/test_rem_attack.py::TestRuthlessMcgrep::test_mcgrep_run_search_with_long_lines
FAILED tests/ruthless/test_rem_attack.py::TestRuthlessMcgrep::test_mcgrep_invalid_result_structure
FAILED tests/ruthless/test_repo_validator.py::TestCLIIntegration::test_llmc_repo_validate_command_exists
FAILED tests/ruthless/test_watcher_fix.py::test_watcher_import_no_pyinotify
FAILED tests/security/test_command_injection.py::test_llmc_backend_injection_sync
FAILED tests/security/test_pocs.py::test_poc_llmc_flag_injection - AssertionE...
FAILED tests/test_docgen_ruthless_config.py::test_load_shell_backend_allows_path_traversal
FAILED tests/test_enrichment_aegis_data.py::test_enrich_aegis_repository_basic
FAILED tests/test_enrichment_aegis_data.py::test_enrich_aegis_data_integrity
FAILED tests/test_enrichment_data_integration_failure.py::TestEnrichmentDataIntegrationSuccess::test_graph_has_enrichment_metadata
FAILED tests/test_indexer_basic.py::test_index_repo_creates_db_and_spans_export
FAILED tests/test_indexer_basic.py::test_index_repo_skips_unchanged_files - P...
FAILED tests/test_mcp_http_transport.py::TestMCPHttpServerConfiguration::test_uses_config_host_and_port
FAILED tests/test_mcp_http_transport.py::TestMCPHttpServerConfiguration::test_init_overrides_config
FAILED tests/test_mcp_http_transport.py::TestMCPHttpServerConfiguration::test_creates_sse_transport
FAILED tests/test_mcp_http_transport.py::TestMCPHttpServerConfiguration::test_creates_starlette_app
FAILED tests/test_medical_integration.py::TestMedicalRAGIntegration::test_negation_detection_f1
FAILED tests/test_medical_integration.py::TestMedicalRAGIntegration::test_phi_coverage
FAILED tests/test_medical_search.py::test_evaluation_metrics - assert 0.66666...
FAILED tests/test_phase2_enrichment_integration.py::TestPhase2EnrichmentIntegration::test_enriched_graph_has_metadata
FAILED tests/test_phase2_enrichment_integration.py::TestPhase2EnrichmentIntegration::test_enriched_graph_preserves_ast_metadata
FAILED tests/test_phase2_enrichment_integration.py::TestPhase2EnrichmentIntegration::test_entity_location_fields_populated
FAILED tests/test_phase2_enrichment_integration.py::TestPhase2EnrichmentIntegration::test_enriched_graph_saves_to_json
FAILED tests/test_phi_filter.py::test_phi_detector_basic - AssertionError: as...
FAILED tests/test_phi_filter.py::test_phi_filter_name_surrogates - AssertionE...
FAILED tests/test_phi_filter.py::test_phi_filter_edge_cases - AssertionError:...
FAILED tests/test_qwen_enrich_batch_static.py::test_qwen_enrich_batch_mypy_clean
FAILED tests/test_rag_nav_enriched_tools.py::TestEnrichedTools::test_tool_search_attaches_graph_enrichment
FAILED tests/test_rag_nav_enriched_tools.py::TestEnrichedTools::test_tool_where_used_attaches_enrichment
FAILED tests/test_rag_router.py::TestRAGRouterTierDecision::test_decide_tier_validation_required
FAILED tests/test_rag_router.py::TestRAGRouterTierDecision::test_decide_tier_complex_reasoning
FAILED tests/test_rag_router.py::TestRAGRouterTierDecision::test_decide_tier_large_context
FAILED tests/test_rag_router.py::TestRAGRouterTierDecision::test_decide_tier_simple_high_confidence
FAILED tests/test_rag_router.py::TestRAGRouterTierDecision::test_decide_tier_simple_no_codebase
FAILED tests/test_rag_router.py::TestRAGRouterTierDecision::test_decide_tier_testing_routes_to_mid
FAILED tests/test_rag_router.py::TestRAGRouterTierDecision::test_decide_tier_bug_hunting_routes_to_mid
FAILED tests/test_rag_router.py::TestRAGRouterTierDecision::test_decide_tier_default_to_mid
FAILED tests/test_rag_router.py::TestRAGRouterCostEstimation::test_cost_estimation_local_is_free
FAILED tests/test_rag_router.py::TestRAGRouterCostEstimation::test_cost_estimation_mid_tier
FAILED tests/test_rag_router.py::TestRAGRouterCostEstimation::test_cost_estimation_premium_tier
FAILED tests/test_rag_router.py::TestRAGRouterCostEstimation::test_cost_estimate_includes_input_and_output
FAILED tests/test_rag_router.py::TestRAGRouterRAGIntegration::test_analyze_query_with_rag
FAILED tests/test_rag_router.py::TestRAGRouterRAGIntegration::test_analyze_query_fallback_on_error
FAILED tests/test_rag_router.py::TestRAGRouterRAGIntegration::test_decide_tier_gets_rag_results
FAILED tests/test_rag_router.py::TestRAGRouterRAGIntegration::test_decide_tier_no_rag_for_local
FAILED tests/test_rag_router.py::TestRAGRouterRouteMethod::test_route_with_forced_routing
FAILED tests/test_rag_router.py::TestRAGRouterRouteMethod::test_route_with_rag_analysis
FAILED tests/test_rag_router.py::TestRouteQueryConvenienceFunction::test_route_query_creates_router
FAILED tests/test_rag_router.py::TestRouteQueryConvenienceFunction::test_route_query_auto_detects_repo_root
FAILED tests/test_rag_router.py::TestRouteQueryConvenienceFunction::test_route_query_calls_route
FAILED tests/test_rag_router.py::TestRAGRouterErrorHandling::test_analyze_query_handles_empty_plan
FAILED tests/test_rag_router.py::TestRAGRouterErrorHandling::test_analyze_query_handles_malformed_spans
FAILED tests/test_rag_router.py::TestRAGRouterErrorHandling::test_decide_tier_handles_missing_rag_results
FAILED tests/test_rag_router.py::TestRAGRouterEdgeCases::test_multiple_forced_routing_matches
FAILED tests/test_rag_router.py::TestRAGRouterEdgeCases::test_context_token_calculation
FAILED tests/test_rag_score_normalization.py::test_score_normalization_clamping
FAILED tests/test_refresh_sync_cron_scripts.py::TestRagRefresh::test_passes_args_to_runner
FAILED tests/test_scheduler_eligibility_comprehensive.py::test_scheduler_run_tick_with_mixed_states
FAILED tests/test_scheduler_eligibility_comprehensive.py::test_scheduler_run_tick_with_force_flags
FAILED tests/test_search_command_regression.py::test_search_command_uses_correct_attributes
90 failed, 2068 passed, 148 skipped, 3 warnings, 3 errors in 215.95s (0:03:35)
