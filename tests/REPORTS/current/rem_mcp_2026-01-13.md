# MCP Tool Test Report - 2026-01-13

## Tool: `run_cmd`

Found in: `llmc_mcp/tools/cmd.py`

### Test Plan

#### 1. Basic Invocation
- [x] Run a simple, harmless command (`ls -l`).
- [x] Verify successful execution and expected output.

#### 2. Parameter Validation
- **`command`**:
  - [x] Test with an empty string.
  - [x] Test with invalid syntax (e.g., unmatched quotes).
- **`cwd`**:
  - [x] Test with a non-existent directory.
  - [x] Test with a file instead of a directory.
- **`blacklist`**:
  - [x] Test with a blacklisted command.
- **`timeout`**:
  - [x] Test with a command that exceeds the timeout.

#### 3. Error Handling
- [x] Test with a command that produces an error (e.g., `ls non_existent_file`).

#### 4. Security
- **`require_isolation`**:
  - [x] Test without isolation (should fail).
  - [x] Test with `LLMC_ISOLATED=1` bypass (should succeed).
- **Blacklist Bypass**:
  - [x] Test with a full path to a blacklisted command.
  - [x] Test with shell metacharacters.
- **Path Traversal in `cwd`**:
  - [x] Test `cwd` with `../../..`.

### Test Execution

- **`require_isolation` (no bypass):** Ran `run_cmd` in a default environment. The tool correctly raised a `RuntimeError` due to the missing isolation.
- **`require_isolation` (with bypass):** Set `LLMC_ISOLATED=1` and ran `run_cmd`. The tool bypassed the isolation check and executed the command successfully.
- **Basic Invocation:** Successfully ran `ls -l` with the isolation bypass.
- **Parameter Validation (`command`):**
  - Empty command: Correctly returned `success=False` and `error='Empty command'`.
  - Invalid syntax: Correctly returned `success=False` and `error='Invalid command syntax: No closing quotation'`.
- **Parameter Validation (`cwd`):**
  - Non-existent directory: Correctly returned `success=False` and a `FileNotFoundError`.
  - File as directory: Correctly returned `success=False` and a `NotADirectoryError`.
- **Parameter Validation (`blacklist`):** Correctly blocked a blacklisted command.
- **Parameter Validation (`timeout`):** Correctly timed out a long-running command.
- **Error Handling:** Correctly returned `success=False` and the error message in `stderr` for a command that produces an error.
- **Security (Blacklist Bypass):**
  - Full path: The blacklist was not bypassed when using a full path to the command.
  - Shell metacharacters: `shlex.split` correctly handled shell metacharacters, preventing command injection.
- **Security (Path Traversal):** The `resolve()` method on the `cwd` path correctly prevented directory traversal beyond the root of the filesystem. The command was executed in the root directory (`/`).

---

## Tool: `execute_code`

Found in: `llmc_mcp/tools/code_exec.py`

### Test Plan

#### 1. Basic Invocation
- [x] Execute a simple `print("hello world")` script.

#### 2. Parameter Validation
- **`code`**:
  - [x] Test with empty code.
  - [x] Test with invalid Python syntax.
- **`timeout`**:
  - [x] Test with a script that sleeps longer than the timeout.

#### 3. Error Handling
- [x] Test with a script that raises an exception.

#### 4. Security
- **`require_isolation`**:
  - [x] Test without isolation (should fail).
  - [x] Test with `LLMC_ISOLATED=1` bypass (should succeed).
- **Filesystem Access**:
  - [ ] Try to read a file from the filesystem.
  - [ ] Try to write a file to the filesystem.
- **Subprocess Escape**:
  - [ ] Try to import `os` and run shell commands.
- **`_call_tool`**:
  - [ ] Test that calling a stub fails as expected.

### Test Execution

- **`require_isolation` (no bypass):** Correctly failed when run without isolation.
- **`require_isolation` (with bypass):** Correctly ran with the `LLMC_ISOLATED=1` bypass.
- **Basic Invocation:** Successfully executed `print("hello world")` and captured the output.
- **Parameter Validation (`code`):**
  - Empty code: Handled gracefully, returned `success=True`.
  - Invalid syntax: Correctly returned `success=False` with a `SyntaxError` in `stderr`.
- **Parameter Validation (`timeout`):** Correctly timed out a long-running script.
- **Error Handling:** Correctly returned `success=False` with the exception traceback in `stderr`.

