#!/usr/bin/env python3
"""
search_files - MCP Filesystem compatible file search.

Implements the MCP search_files tool interface.
Recursively searches for files matching a glob pattern.

Usage:
    ./search_files '{"path": "src/", "pattern": "*.py"}'
    ./search_files '{"path": ".", "pattern": "test_*.py", "excludePatterns": ["__pycache__"]}'
"""
import fnmatch
import json
import os
import sys
from pathlib import Path


def validate_path(path: str) -> tuple[bool, str]:
    """Validate path is under allowed roots."""
    allowed_roots_str = os.environ.get("LLMC_ALLOWED_ROOTS", os.getcwd())
    allowed_roots = [Path(r).resolve() for r in allowed_roots_str.split(":")]
    
    resolved = Path(path).resolve()
    
    for root in allowed_roots:
        try:
            resolved.relative_to(root)
            return True, ""
        except ValueError:
            continue
    
    return False, f"Path '{path}' is outside allowed roots: {allowed_roots_str}"


def search_recursive(root: Path, pattern: str, exclude_patterns: list[str], max_results: int = 100) -> list[str]:
    """Recursively search for files matching pattern."""
    matches = []
    
    try:
        for item in root.rglob("*"):
            if len(matches) >= max_results:
                break
            
            if not item.is_file():
                continue
            
            # Check if matches pattern
            if not fnmatch.fnmatch(item.name, pattern):
                continue
            
            # Check excludes
            rel_path = str(item.relative_to(root))
            excluded = False
            for exc in exclude_patterns:
                if fnmatch.fnmatch(rel_path, exc) or fnmatch.fnmatch(item.name, exc):
                    excluded = True
                    break
                # Also check if any parent matches
                for parent in item.relative_to(root).parents:
                    if fnmatch.fnmatch(str(parent), exc):
                        excluded = True
                        break
            
            if not excluded:
                matches.append(rel_path)
    except PermissionError:
        pass
    
    return matches


def main():
    # Parse input from arg or stdin
    if len(sys.argv) > 1:
        raw_input = sys.argv[1]
    else:
        raw_input = sys.stdin.read().strip()
    
    if not raw_input:
        print(json.dumps({
            "success": False,
            "error": "No input provided. Expected JSON with 'path' and 'pattern' fields."
        }))
        sys.exit(1)
    
    try:
        args = json.loads(raw_input)
    except json.JSONDecodeError as e:
        print(json.dumps({
            "success": False,
            "error": f"Invalid JSON: {e}"
        }))
        sys.exit(1)
    
    # Validate required fields
    dir_path = args.get("path")
    if not dir_path:
        print(json.dumps({
            "success": False,
            "error": "Missing required field: 'path'"
        }))
        sys.exit(1)
    
    pattern = args.get("pattern")
    if not pattern:
        print(json.dumps({
            "success": False,
            "error": "Missing required field: 'pattern'"
        }))
        sys.exit(1)
    
    exclude_patterns = args.get("excludePatterns", [])
    if not isinstance(exclude_patterns, list):
        exclude_patterns = []
    
    # Security check
    valid, error = validate_path(dir_path)
    if not valid:
        print(json.dumps({
            "success": False,
            "error": error
        }))
        sys.exit(2)
    
    resolved_path = Path(dir_path).resolve()
    
    if not resolved_path.exists():
        print(json.dumps({
            "success": False,
            "error": f"Directory not found: {dir_path}"
        }))
        sys.exit(1)
    
    if not resolved_path.is_dir():
        print(json.dumps({
            "success": False,
            "error": f"Not a directory: {dir_path}"
        }))
        sys.exit(1)
    
    try:
        matches = search_recursive(resolved_path, pattern, exclude_patterns)
        
        print(json.dumps({
            "success": True,
            "path": str(resolved_path),
            "pattern": pattern,
            "matches": matches,
            "count": len(matches)
        }))
        
    except Exception as e:
        print(json.dumps({
            "success": False,
            "error": f"Search failed: {e}"
        }))
        sys.exit(1)


if __name__ == "__main__":
    main()
