# HLD: Unified CLI & TUI Overhaul ("Cyberpunk Console" v2)

**Status:** DRAFT
**Date:** 2025-11-19
**Objective:** Re-architect `llmc-cli` from a passive static-file viewer into a fully interactive, data-integrated TUI application that serves as the primary interface for the LLMC RAG system.

---

## 1. Problem Statement

The current `llmc/cli.py` (v0.5.0) is a "Potemkin Village":
1.  **Disconnected Data:** It reads a static artifact (`rag_graph.json`) generated by a separate process. It does not query the live indices (FTS, Enrichment DB).
2.  **Broken Search:** The `search` command is a stub; it does not invoke the actual `tool_rag_search` logic present in `tools/rag_nav`.
3.  **Passive Monitoring:** It can display "last updated" timestamps but cannot trigger refreshes, manage the daemon, or debug the enrichment pipeline.
4.  **Fragile Join:** The "join" between AST structure and Enrichment semantics happens only during the expensive `build_graph` step, meaning the CLI's view is always stale compared to the DB.

## 2. High-Level Solution

We will rebuild the CLI using **Textual**, a robust TUI framework for Python, to create an **active client** of the RAG Service.

**Core Shift:**
*   **Old:** CLI -> reads `json` file -> prints text.
*   **New:** TUI App -> instantiates `GraphStore` / `Database` / `DaemonClient` -> queries live data -> renders interactive widgets.

---

## 3. Architecture

### 3.1 The "Unified Client" Layer
We will introduce a `RAGClient` class in `llmc/client.py` (new) that acts as the single entry point for all UI operations.

```python
class RAGClient:
    def __init__(self, repo_root: Path):
        self.repo_root = repo_root
        self.fts_db = Database(index_path_for_write(repo_root)) # FTS/Enrichment DB
        self.status = load_status(repo_root)
        self.graph = None # Lazy loaded via tools.rag_nav.tool_handlers._load_graph

    def search(self, query: str) -> List[SearchResult]:
        # Calls the REAL logic from tools.rag_nav.tool_handlers.tool_rag_search
        return tool_rag_search(query, self.repo_root)

    def get_node_details(self, node_id: str) -> EnrichedEntity:
        # Fetches live enrichment data for a specific node
        # Joins Graph Node + DB Record on demand
        pass
        
    def get_daemon_status(self) -> DaemonState:
        # Checks PID / Socket
        pass
```

### 3.2 The TUI Application (`llmc/tui.py`)
Using `Textual`, we will implement a "Cyberpunk Console" with tabbed navigation:

*   **Layout:**
    *   **Header:** Status bar (Freshness: FRESH/STALE, Daemon: ON/OFF).
    *   **Main Area:** Tabbed Content.
        *   `[Monitor]`: The existing 6-panel stats grid (ported to Textual widgets).
        *   `[Navigator]`: A tree view of the repo (File -> Class -> Method). Selecting a node shows its **Enrichment Data** in a side panel.
        *   `[Search]`: A real-time search bar. Typing triggers `RAGClient.search()` and renders results. Enter jumps to the file/node in Navigator.
        *   `[Control]`: Buttons to "Rebuild Index", "Start Daemon", "Enrich Now".
    *   **Footer:** Log stream (tailing `rag-service.log`).

### 3.3 The Data Join Strategy

Instead of relying on a pre-baked `rag_graph.json` for everything:
1.  **Structure:** We still load the `SchemaGraph` for the "Navigator" tree structure (files/classes).
2.  **Semantics (Enrichment):** We **lazy-load** enrichment data. When a user selects a node in the TUI, we query the `enrichment.db` by `span_hash` to get the summary, inputs, outputs, and warnings.
    *   *Benefit:* The TUI always shows the latest DB state, even if the graph export is slightly older.

---

## 4. Implementation Phases

### Phase 1: The Wiring (Logic Only)
*   Create `llmc/client.py`.
*   Move `tools/rag_nav/tool_handlers.py` logic into reusable "service" functions if they are too coupled to CLI args.
*   Verify `RAGClient.search("auth")` returns real hits from the FTS DB.

### Phase 2: The TUI Foundation
*   Initialize a basic `Textual` app (`llmc/tui/app.py`).
*   Implement the **Monitor** tab (porting the existing `Rich` layout).
*   Implement the **Log** footer (tailing the log file).

### Phase 3: The Navigator & Search (The "Big Feature")
*   Implement the **Tree Widget** populated by `SchemaGraph`.
*   Implement the **Detail View** that queries `RAGClient` for enrichment data.
*   Implement the **Search Input** that filters the tree or shows a results list.

### Phase 4: Daemon Control
*   Add buttons to trigger `subprocess` calls to `llmc-rag-service`.
*   Add visual indicators for daemon health.

---

## 5. Key Files & Dependencies

*   `llmc/tui/`: New package for UI code.
*   `llmc/client.py`: The facade over `tools.rag.*`.
*   `tools/rag_nav/`: The existing logic (no major refactors needed, just exposure).
*   **Deps:** `textual`, `textual-dev`.

## 6. Risk Assessment

*   **Performance:** Loading the full graph into a Tree widget might be slow for massive repos.
    *   *Mitigation:* Lazy-load tree branches (Files -> Classes only on expand).
*   **Complexity:** Textual is stateful and async.
    *   *Mitigation:* Keep state management simple (React-style reactive attributes).

---

## 7. Next Steps for "Deep Researcher"

1.  Analyze `Textual`'s `Tree` widget capabilities for lazy loading.
2.  Verify `tools.rag.schema.SchemaGraph` structureâ€”is it easy to traverse as a tree?
3.  Prototype the `RAGClient` class to prove we can "join" Graph and DB in real-time.
