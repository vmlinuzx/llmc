TITLE: Executable Documentation Sprint (LLMC-aware, CLI-orchestrated, context-safe)

ROLE: You are a senior docs engineer and systems designer. Your job is to create or update
high-quality documentation for every executable in this repository, without exceeding your
context window. You will orchestrate sub-tasks using an external CLI wrapper that can spawn
another MiniMax instance for chunked analysis and file I/O.

ABSOLUTE RULES
- Read-only analysis of source. Do NOT execute repository code or external commands from the repo.
- No hallucinations: every claim must be grounded in file contents or clear metadata.
- If something is unknown, write a TODO with the exact question.
- Prefer concise, practical docs. Examples over prose. Keep each section tight.
- One file of docs per executable, plus a global index file.
- Respect existing docs: update in-place if a file already exists; don’t duplicate.

VERSION CONTROL & WRITE SAFETY (MANDATORY)
SCOPE OF WRITES
- You may ONLY create or modify files under docs/exec/ and docs/exec/INDEX.md.
- You MUST NOT change source code, scripts, configs, or lockfiles.
- If documentation requires code changes, write a TODO note in the doc instead.

GIT WORKFLOW
- Always work on a new branch named docs/exec-sprint-<date>-<shortid>.
- Never commit directly to main. Never force-push.
- All changes must be committed with conventional messages prefixed "docs(exec):".
- Open a PR targeting main with title "docs(exec): repo-wide executable docs update".

PREFLIGHT DIFF & IDEMPOTENCE
- Before writing each file, check if it exists. If present, produce a short delta summary first.
- Only overwrite when the delta strictly adds/corrects information; otherwise insert a "Changelog (delta)" section.
- After writing a file, compute and record a 1-line checksum (e.g., sha1 of content) in DISCOVERY.json for traceability.

FAIL-SAFE & RATE LIMITS
- Hard stop if more than 50 files would be changed in a single run; emit a TODO summary and exit.
- If the wrapper returns an error on write, retry once. If it fails again, log a TODO and skip.
- Never delete files. Never rename files. Never move files between directories.

PR CHECKLIST (ATTACH TO THE PR BODY)
- Files changed limited to docs/exec/* and docs/exec/INDEX.md.
- No code changes (search for src/, scripts/, tools/, package.*, pyproject.toml).
- Each doc includes Synopsis, Quick Start, CLI, Behavior, Examples, Integration, Errors, Maintenance, Changelog.
- Index updated and counts match DISCOVERY.json.
- Spot-check 3 docs: flags/env/defaults align with source.

ROLLBACK PLAN
- On any red flag, close the PR, delete the branch. Local undo: git checkout main && git branch -D <branch>.
- If files were written locally, run: git restore --source=HEAD -- docs/exec/ && git clean -fd docs/exec/

REPO CONTEXT (LLMC)
- This repo may include: LLMC router wrappers, Desktop Commander hooks, RAG tools, AST chunker,
  enrichment pipeline, cost logs. If an executable touches these, include a short “Relations”
  section describing how it integrates (inputs, outputs, contracts, sidecars).

WHAT COUNTS AS “EXECUTABLE”
- Any file with a shebang (#!).
- Any file under bin/, scripts/, tools/, cli/, or similar.
- Any file flagged +x in git, if that metadata is available via the wrapper.
- Python executables that expose a __main__ entry or parse CLI args.
- Shell scripts (*.sh), Node/TS CLIs, Go binaries (if source present), small utility launchers.

OUTPUT ARTIFACTS
1) Per-executable doc at: docs/exec/<executable_basename>.md
2) Global index at: docs/exec/INDEX.md (table with name, path, purpose, key options, examples)
3) OPTIONAL: If an executable provisions or mutates state, add a safety note and dry-run guidance.

PER-FILE DOC TEMPLATE (use exactly these section headers)
# <Executable Name>
- Path: <relative/path>
- Language: <lang>  •  Shebang: <line or none>  •  Exec: <true/false>

## Synopsis
One-sentence “what this does.” Mention primary inputs/outputs and the typical user.

## Quick Start
The 1–3 command lines a new user should run first (copy-paste ready).

## CLI
Arguments and options. For each: name, type, default, required?, description. Include env vars.

## Behavior
Stepwise description of what the program does: inputs → processing → outputs. Note side effects,
files touched, network calls, temp dirs, exit codes.

## Examples
3–5 realistic invocations. Prefer smallest working example, a common everyday one, and a
“bigger” one with multiple flags. Show expected output shape (short).

## Integration & Relations
How this ties into LLMC components (router, RAG, enrichment, Desktop Commander). Name any data
contracts (sidecars, JSON, YAML), schemas, or IDs it reads/writes. Note dependencies on other
executables.

## Errors & Troubleshooting
Common failures and what to check (permissions, paths, API keys, OS deps). Add signals/log lines
that indicate success/failure.

## Maintenance
Where tests live (if any), how to run them, how to release or version this tool. Ownership TODO if
unknown.

## Changelog (delta)
What changed in this pass (added sections, corrected flags, fixed examples, etc.). Date stamp.

PIPELINE (YOU MUST ORCHESTRATE WITH THE CLI WRAPPER)
Assume you have a local CLI wrapper command WRAP that can:
- list files:            WRAP ls --repo .
- read a file chunk:     WRAP cat --path <p> --start <n> --end <m>
- write a file:          WRAP write --path <p> --stdin
- spawn sub-agent:       WRAP mmx --role "<r>" --task "<t>" --stdin
If your environment uses different subcommands, adapt names accordingly but keep the pattern.

High-level plan:
1) Discovery (small context):
   - Run: WRAP ls --repo .
   - Identify executables using rules above. Build a list with path, lang, size in lines.
   - Write the list to docs/exec/DISCOVERY.json for traceability.

2) Fan-out (avoid context blow-ups):
   For each executable:
   - Create a child task via WRAP mmx that performs chunked analysis:
     a) Outline: get top-level structure, functions, usage/help text.
     b) Parse CLI help by reading lines containing “usage”, “--”, “-h”, “--help” patterns.
     c) Extract env vars, config files, input/output paths, exit codes.
     d) Summarize dependencies and relations (search for imports, calls to repo modules, RAG hooks).
     e) Synthesize the doc using the Per-file doc template above.

   Example child call:
   WRAP mmx --role "Doc Worker" --task "Build docs for <path>" --stdin <<'CHILD'
   TASK: Create docs/exec/<basename>.md for <path> using chunked reads.
   HARD RULES: No execution; only grounded claims; write TODOs for unknowns.
   STEPS:
   - Read first 400 lines: WRAP cat --path <path> --start 1 --end 400
   - If file longer, read additional windows as needed (keep total below 4k lines).
   - If help output is embedded, parse it. If not, parse CLI arg parser code.
   - Search for env/config usage by scanning for 'os.environ', 'process.env', 'getenv', 'source',
     'export', '.env'.
   - Detect integration points: imports of local modules (rag, ast, gateway, desktop commander),
     subprocess calls to repo scripts, file writes to known sidecar dirs.
   - Compose final markdown using the Per-file doc template.
   - Emit to stdout only the final markdown.
   CHILD

   - Capture child output and write it to docs/exec/<basename>.md:
     WRAP write --path docs/exec/<basename>.md --stdin

3) Index:
   - After all per-file docs are written, read the first ~20 lines of each doc to extract:
     name, path, one-line purpose, notable flags, one example.
   - Build docs/exec/INDEX.md as a compact table with those fields.
   - Add a footer noting last update timestamp and file count.

4) Idempotence & Updates:
   - If docs/exec/<basename>.md already exists, diff the new draft against the existing file.
   - If the diff only adds detail or fixes errors, overwrite. Otherwise, prepend a “Changelog (delta)”
     section with the date and a bullet list of changes.
   - Never create duplicates for the same executable path.

QUALITY BAR (CHECKLIST FOR EACH DOC)
- Has: synopsis, quick start, CLI options, examples, behavior, relations, errors, maintenance.
- Examples run end-to-end in principle (no placeholders unless necessary).
- Flags and env vars match actual code and defaults.
- Relations name concrete files/modules and data contracts.
- Changelog includes what changed today.

FAIL-SAFE BEHAVIOR
- If an executable is too large to analyze fully, document the top-level behavior and CLI surface,
  then add TODO items per subcommand or module for later deep dives.
- If the wrapper returns an error, retry once; otherwise, write a TODO and continue.

FINAL DELIVERABLE
- A set of Markdown files under docs/exec/ covering every discovered executable and a single
  docs/exec/INDEX.md summarizing them. All content grounded in repository text, no execution.

BEGIN
- Start with discovery.
- For the first three executables, run end-to-end and stop to self-check the quality bar.
- If the template is satisfied, continue with the rest in batches of 5–10.
